<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Task Intervals</title>
  <style>
    :root {
      --bg: #0f172a;
      --card: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22c55e;
      --danger: #ef4444;
      --primary: #3b82f6;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(180deg, #0f172a 0%, #0b1222 100%);
      color: var(--text);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      padding: 16px 16px 8px 16px;
    }
    .title {
      margin: 0 0 4px 0;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    .subtitle {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
    }

    .content {
      flex: 1;
      padding: 12px 12px 72px 12px; /* bottom space for nav */
    }

    .screen { display: none; }
    .screen.active { display: block; }

    .card {
      background: radial-gradient(120% 140% at 10% 10%, #0b1222 0%, #0a0f1d 45%, #0a0e1b 100%);
      border: 1px solid #1f2937;
      border-radius: 14px;
      padding: 14px;
      margin-bottom: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
    }
    .card h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      color: #cbd5e1;
      font-weight: 600;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .interval {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #0b1221;
      border: 1px solid #1e293b;
      border-radius: 12px;
      padding: 10px 12px;
    }
    .interval.disabled { opacity: 0.55; filter: saturate(0.7); }
    .interval .meta {
      font-size: 12px;
      color: var(--muted);
    }
    .interval .task {
      font-size: 14px;
      font-weight: 600;
    }

    .history-list { display: grid; gap: 8px; }

    .muted { color: var(--muted); }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #0b1530;
      border: 1px solid #1d2947;
      font-size: 12px;
      color: #9fb4ff;
    }
    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #0e1a33;
      border: 1px solid #21345d;
      font-size: 11px;
      color: #c7d2fe;
      margin-right: 6px;
      margin-top: 4px;
    }
    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #0e1a33;
      border: 1px solid #21345d;
      font-size: 11px;
      color: #c7d2fe;
      margin-right: 6px;
      margin-top: 4px;
    }

    input, select, button, textarea {
      font: inherit;
      color: var(--text);
    }
    .field {
      display: grid;
      gap: 6px;
      margin-bottom: 12px;
    }
    .field label { font-size: 13px; color: #cbd5e1; }
    .input {
      background: #0a1020;
      border: 1px solid #1f2a44;
      border-radius: 10px;
      padding: 10px 12px;
      outline: none;
      transition: border 0.15s ease;
    }
    .input:focus { border-color: #335ccf; }

    .btn {
      background: linear-gradient(180deg, #3b82f6 0%, #2b68c7 100%);
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      color: white;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(59,130,246,0.25);
    }
    .btn.small { padding: 6px 10px; font-size: 12px; font-weight: 600; }
    .btn.secondary {
      background: linear-gradient(180deg, #22c55e 0%, #19924a 100%);
      box-shadow: 0 8px 20px rgba(34,197,94,0.22);
    }
    .btn.danger {
      background: linear-gradient(180deg, #ef4444 0%, #c03434 100%);
      box-shadow: 0 8px 20px rgba(239,68,68,0.22);
    }

    .actions { display: flex; gap: 8px; flex-wrap: wrap; }

    nav.bottom {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      height: 56px;
      backdrop-filter: blur(10px);
      background: rgba(8, 12, 22, 0.7);
      border-top: 1px solid #1f2937;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      align-items: center;
    }
    .tab-btn {
      appearance: none;
      background: transparent;
      color: var(--muted);
      border: none;
      height: 100%;
      font-weight: 700;
      cursor: pointer;
    }
    .tab-btn.active {
      color: #ffffff;
      position: relative;
    }
    .tab-btn.active::after {
      content: "";
      position: absolute;
      left: 24px; right: 24px; bottom: 6px;
      height: 3px; border-radius: 3px; background: #3b82f6;
    }

    .small { font-size: 12px; }

    /* Action menu for tasks */
    .menu-wrap { position: relative; margin-left: auto; }
    .menu-trigger {
      background: transparent;
      border: 1px solid #1f2a44;
      color: #cbd5e1;
      border-radius: 8px;
      padding: 6px 8px;
      cursor: pointer;
    }
    .menu {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 6px;
      background: #0a1020;
      border: 1px solid #1f2a44;
      border-radius: 8px;
      min-width: 140px;
      display: none;
      z-index: 20;
      box-shadow: 0 10px 20px rgba(0,0,0,0.4);
    }
    .menu.open { display: block; }
    .menu-item {
      display: block;
      width: 100%;
      padding: 8px 10px;
      background: transparent;
      border: none;
      color: #e5e7eb;
      text-align: left;
      cursor: pointer;
    }
    .menu-item:hover { background: #0f1a36; }
    .menu-item.danger { color: #fca5a5; }

    /* Action menu for tasks */
    .menu-wrap { position: relative; margin-left: auto; }
    .menu-trigger {
      background: transparent;
      border: 1px solid #1f2a44;
      color: #cbd5e1;
      border-radius: 8px;
      padding: 6px 8px;
      cursor: pointer;
    }
    .menu {
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 6px;
      background: #0a1020;
      border: 1px solid #1f2a44;
      border-radius: 8px;
      min-width: 140px;
      display: none;
      z-index: 20;
      box-shadow: 0 10px 20px rgba(0,0,0,0.4);
    }
    .menu.open { display: block; }
    .menu-item {
      display: block;
      width: 100%;
      padding: 8px 10px;
      background: transparent;
      border: none;
      color: #e5e7eb;
      text-align: left;
      cursor: pointer;
    }
    .menu-item:hover { background: #0f1a36; }
    .menu-item.danger { color: #fca5a5; }

    /* Progress Bar */
    .progress {
      margin-top: 10px;
      display: grid;
      gap: 6px;
    }
    .progress-track {
      position: relative;
      height: 10px;
      background: #0a1020;
      border: 1px solid #1f2a44;
      border-radius: 999px;
    }
    .progress-complete {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0%;
      background: #3b82f6;
      opacity: 0.35;
      border-radius: 999px;
      transition: width 0.2s ease;
    }
    .progress-marker {
      position: absolute;
      top: 0;
      left: 0%;
      height: 100%;
      width: 2px;
      background: #ffffff;
      box-shadow: 0 0 0 2px rgba(59,130,246,0.25), 0 0 8px rgba(59,130,246,0.4);
      transform: translateX(-50%);
      border-radius: 2px;
    }
    .progress-meta {
      display: flex; justify-content: space-between; align-items: center;
      font-size: 12px; color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1 class="title">Task Intervals</h1>
    <p class="subtitle">Overview, quick add, and settings for interval length</p>
  </header>

  <main class="content">
    <!-- Overview Screen -->
    <section id="screen-overview" class="screen active">
      <div class="card">
        <h3>Last task</h3>
        <div id="last-interval" class="interval">
          <div>
            <div class="task" id="last-task-title">No task</div>
          </div>
        </div>
      </div>
      <div class="card">
        <h3>Current task</h3>
        <div id="current-interval" class="interval">
          <div>
            <div class="meta" id="current-range">--:-- â€” --:--</div>
            <div class="task" id="current-task">No task</div>
          </div>
          <span class="pill" id="current-index">#</span>
        </div>
        <div class="progress">
          <div class="progress-track">
            <div id="progress-complete" class="progress-complete"></div>
            <div id="progress-marker" class="progress-marker"></div>
          </div>
          <div class="progress-meta">
            <span id="progress-percent">0%</span>
            <span id="progress-remaining">--:-- remaining</span>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Next 3 tasks</h3>
        <div id="upcoming" class="history-list"></div>
      </div>
    </section>

    <!-- Add Task Screen -->
    <section id="screen-add" class="screen">
      <div class="card">
        <h3>Add task</h3>
        <div class="field">
          <label for="task-title">Title</label>
          <input id="task-title" class="input" type="text" placeholder="e.g., Write report" />
        </div>
        <div class="field">
          <label for="task-tags">Tags (comma separated)</label>
          <input id="task-tags" class="input" type="text" placeholder="e.g., home, work" list="tag-suggestions" />
          <datalist id="tag-suggestions"></datalist>
          <div class="small muted">New tags are created automatically when you add the task.</div>
        </div>
        <div class="field">
          <label for="task-intervals">Intervals needed</label>
          <input id="task-intervals" class="input" type="number" min="1" step="1" value="1" />
        </div>
        <div class="field">
          <label class="small"><input type="checkbox" id="start-next" checked /> Start from next interval (not current)</label>
        </div>
        <div class="actions">
          <button id="add-btn" class="btn">Add and schedule</button>
        </div>
      </div>

      <div class="card">
        <h3>Queued tasks</h3>
        <div class="field" style="margin-bottom: 8px;">
          <label class="small">Filter by tags</label>
          <div id="task-filter-group"></div>
          <div class="small muted">Select none to show all.</div>
        </div>
        <div id="task-list" class="history-list"></div>
      </div>
    </section>

    <!-- Settings Screen -->
    <section id="screen-settings" class="screen">
      <div class="card">
        <h3>Interval settings</h3>
        <div class="field">
          <label for="interval-mins">Interval length (minutes)</label>
          <input id="interval-mins" class="input" type="number" min="1" step="1" value="25" />
        </div>
        <div class="actions">
          <button id="save-settings" class="btn secondary">Save</button>
          <button id="reset-today" class="btn danger">Reset today's schedule</button>
        </div>
        <p class="small muted" style="margin-top:8px">Changing interval length resets today's schedule to match the new cadence.</p>
      </div>
      <div class="card">
        <h3>Tags</h3>
        <div id="tag-list" class="history-list"></div>
        <p class="small muted" style="margin-top:8px">Disable a tag to exclude those tasks from future intervals today. Untagged applies to tasks without any tags.</p>
      </div>
    </section>
  </main>

  <nav class="bottom">
    <button class="tab-btn active" data-tab="overview">Overview</button>
    <button class="tab-btn" data-tab="add">Add</button>
    <button class="tab-btn" data-tab="settings">Settings</button>
  </nav>

  <script>
    // --- Storage Keys ---
    const SETTINGS_KEY = "ti_settings_v1";
    const TASKS_KEY = "ti_tasks_v1";
    const SCHEDULE_PREFIX = "ti_schedule_"; // + YYYY-MM-DD
    const TAGS_KEY = "ti_tags_v1"; // { [tagName]: { enabled: boolean } }
    const TAG_FILTER_KEY = "ti_tag_filter_v1"; // string[] of selected filter tags
    

    // --- Utilities ---
    function startOfLocalDay(date = new Date()) {
      const d = new Date(date);
      d.setHours(0, 0, 0, 0);
      return d;
    }

    function formatTime(date) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function getTodayKey(date = new Date()) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    function loadSettings() {
      const raw = localStorage.getItem(SETTINGS_KEY);
      if (!raw) return { intervalMinutes: 25 };
      try { return JSON.parse(raw); } catch { return { intervalMinutes: 25 }; }
    }
    function saveSettings(settings) {
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    }

    function loadTasks() {
      const raw = localStorage.getItem(TASKS_KEY);
      if (!raw) return [];
      try { return JSON.parse(raw); } catch { return []; }
    }
    function saveTasks(tasks) {
      localStorage.setItem(TASKS_KEY, JSON.stringify(tasks));
    }

    function loadSchedule(dayKey) {
      const raw = localStorage.getItem(SCHEDULE_PREFIX + dayKey);
      if (!raw) return {}; // { [intervalIndex]: taskId }
      try { return JSON.parse(raw); } catch { return {}; }
    }
    function loadTags() {
      const raw = localStorage.getItem(TAGS_KEY);
      if (!raw) return {}; // default: no explicit tags yet
      try { return JSON.parse(raw) || {}; } catch { return {}; }
    }
    function saveTags(tagsMap) {
      localStorage.setItem(TAGS_KEY, JSON.stringify(tagsMap));
    }
    function normalizeTagName(tag) { return String(tag || '').trim(); }
    function getTaskTags(task) { const tags = Array.isArray(task?.tags) ? task.tags : []; return tags.map(normalizeTagName).filter(Boolean); }
    function isTagEnabled(tagName, tagsMap) { const t = normalizeTagName(tagName); if (!t) return true; const rec = tagsMap[t]; return rec ? rec.enabled !== false : true; }
    function isTaskAllowedByTags(task, tagsMap) {
      const tags = getTaskTags(task);
      if (tags.length === 0) {
        const rec = tagsMap['Untagged'];
        return rec ? rec.enabled !== false : true;
      }
      for (const tag of tags) { if (!isTagEnabled(tag, tagsMap)) return false; }
      return true;
    }

    // Filter helpers (Add screen selection influences Overview)
    function taskMatchesFilter(task, selectedFilters) {
      const tags = getTaskTags(task);
      if (!selectedFilters || selectedFilters.length === 0) return true;
      // A task matches if any selected filter matches its tags, or '__UNTAGGED__' when it has no tags
      return selectedFilters.some(f => (f === '__UNTAGGED__' ? tags.length === 0 : tags.includes(f)));
    }
    function saveSchedule(dayKey, schedule) {
      localStorage.setItem(SCHEDULE_PREFIX + dayKey, JSON.stringify(schedule));
    }

    // --- Tags helpers ---
    function loadTags() {
      const raw = localStorage.getItem(TAGS_KEY);
      if (!raw) return {};
      try { return JSON.parse(raw) || {}; } catch { return {}; }
    }
    function saveTags(tagsMap) {
      localStorage.setItem(TAGS_KEY, JSON.stringify(tagsMap));
    }
    function normalizeTagName(tag) { return String(tag || '').trim(); }
    function getTaskTags(task) {
      const tags = Array.isArray(task?.tags) ? task.tags : [];
      return tags.map(normalizeTagName).filter(Boolean);
    }
    function isTagEnabled(tagName, tagsMap) {
      const t = normalizeTagName(tagName);
      if (!t) return true;
      const rec = tagsMap[t];
      return rec ? rec.enabled !== false : true;
    }
    function isTaskAllowedByTags(task, tagsMap) {
      const tags = getTaskTags(task);
      if (tags.length === 0) {
        const rec = tagsMap['Untagged'];
        return rec ? rec.enabled !== false : true;
      }
      for (const tag of tags) { if (!isTagEnabled(tag, tagsMap)) return false; }
      return true;
    }

    function getIntervalInfo(now = new Date()) {
      const settings = loadSettings();
      const intervalMs = Math.max(1, Number(settings.intervalMinutes || 25)) * 60 * 1000;
      const sod = startOfLocalDay(now).getTime();
      const diff = now.getTime() - sod;
      const index = Math.max(0, Math.floor(diff / intervalMs));
      const start = new Date(sod + index * intervalMs);
      const end = new Date(start.getTime() + intervalMs);
      return { index, start, end, intervalMs };
    }

    function ensureScheduleConsistency() {
      // If settings changed drastically, we keep schedule per-day; nothing to do across days
      // This function can be expanded to migrate data versions.
      return true;
    }

    // --- Rendering ---
    let lastRenderedIntervalIndex = null;

    // Build the list of task IDs used for cyclic fallback (no free slots)
    function getAvailableTaskIdsForCycle() {
      const tasks = loadTasks();
      const tagsMap = loadTags();
      const selectedFilters = loadTagFilterSelection();
      return tasks
        .filter(t => (t.enabled !== false) && isTaskAllowedByTags(t, tagsMap) && taskMatchesFilter(t, selectedFilters))
        .map(t => t.id);
    }
    // Returns a taskId to use for a given interval index:
    //  - schedule assignment if present
    //  - otherwise, cyclic pick from available tasks by modulo index
    function getEffectiveTaskIdForIndex(index) {
      const dayKey = getTodayKey();
      const schedule = loadSchedule(dayKey);
      const tagsMap = loadTags();
      const selectedFilters = loadTagFilterSelection();
      const tasks = loadTasks();
      const scheduledId = schedule[index];
      if (scheduledId) {
        const t = tasks.find(x => x.id === scheduledId);
        if (t && (t.enabled !== false) && isTaskAllowedByTags(t, tagsMap) && taskMatchesFilter(t, selectedFilters)) {
          return scheduledId;
        }
      }
      const avail = getAvailableTaskIdsForCycle();
      if (avail.length === 0) return null;
      return avail[index % avail.length];
    }

    function getIntervalsPerDay() {
      const settings = loadSettings();
      const intervalMs = Math.max(1, Number(settings.intervalMinutes || 25)) * 60 * 1000;
      const dayMs = 24 * 60 * 60 * 1000;
      return Math.ceil(dayMs / intervalMs);
    }

    // Fill all missing intervals of today by cycling through available tasks from 12:00 AM
    function ensureCyclicScheduleForToday() {
      const availableTaskIds = getAvailableTaskIdsForCycle();
      if (availableTaskIds.length === 0) return;
      const dayKey = getTodayKey();
      const schedule = loadSchedule(dayKey);
      const total = getIntervalsPerDay();
      for (let i = 0; i < total; i++) {
        if (!schedule[i]) {
          schedule[i] = availableTaskIds[i % availableTaskIds.length];
        }
      }
      saveSchedule(dayKey, schedule);
    }

    function renderOverview() {
      const { index, start, end } = getIntervalInfo();
      const dayKey = getTodayKey();
      const schedule = loadSchedule(dayKey);
      const tasks = loadTasks();

      const currentTaskId = getEffectiveTaskIdForIndex(index);
      const currentTaskTitle = currentTaskId ? (tasks.find(t => t.id === currentTaskId)?.title || 'Unknown task') : 'No tasks';
      document.getElementById('current-range').textContent = `${formatTime(start)} â€” ${formatTime(end)}`;
      document.getElementById('current-task').textContent = currentTaskTitle;
      document.getElementById('current-index').textContent = `#${index}`;

      // Last task title
      const lastTitleNode = document.getElementById('last-task-title');
      if (lastTitleNode) {
        const prevIndex = Math.max(0, index - 1);
        const prevTaskId = getEffectiveTaskIdForIndex(prevIndex);
        const prevTaskTitle = prevTaskId ? (tasks.find(t => t.id === prevTaskId)?.title || 'Unknown task') : 'No tasks';
        lastTitleNode.textContent = prevTaskTitle;
      }

      // Remove old prev/next detailed cards logic (handled by sections now)

      // Removed detailed history list

      // Upcoming: show next 3 intervals after current
      const upcomingRoot = document.getElementById('upcoming');
      if (upcomingRoot) {
        upcomingRoot.innerHTML = '';
        const intervalMs = end.getTime() - start.getTime();
        const upcomingCount = 3;
        for (let offset = 1; offset <= upcomingCount; offset++) {
          const i = index + offset;
          const uStart = new Date(end.getTime() + (offset - 1) * intervalMs);
          const uEnd = new Date(uStart.getTime() + intervalMs);
          const effId = getEffectiveTaskIdForIndex(i);
          const title = effId ? (tasks.find(t => t.id === effId)?.title || 'Unknown task') : 'No tasks';
          const row = document.createElement('div');
          row.className = 'interval';
          row.innerHTML = `
            <div>
              <div class="meta">${formatTime(uStart)} â€” ${formatTime(uEnd)}</div>
              <div class="task">${title}</div>
            </div>
          `;
          upcomingRoot.appendChild(row);
        }
      }
    }

    function updateCurrentIntervalProgress() {
      // Only update when Overview screen visible
      if (!document.getElementById('screen-overview').classList.contains('active')) return;
      const { index, start, end } = getIntervalInfo();

      // If rolled into a new interval, re-render the overview
      if (lastRenderedIntervalIndex === null || lastRenderedIntervalIndex !== index) {
        lastRenderedIntervalIndex = index;
        renderOverview();
      }

      const now = new Date();
      const totalMs = Math.max(1, end.getTime() - start.getTime());
      const elapsedMs = Math.min(totalMs, Math.max(0, now.getTime() - start.getTime()));
      const ratio = Math.min(1, Math.max(0, elapsedMs / totalMs));
      const percent = Math.round(ratio * 100);
      const remainingMs = Math.max(0, end.getTime() - now.getTime());
      const mm = Math.floor(remainingMs / 60000);
      const ss = String(Math.floor((remainingMs % 60000) / 1000)).padStart(2, '0');

      const marker = document.getElementById('progress-marker');
      const complete = document.getElementById('progress-complete');
      const pct = document.getElementById('progress-percent');
      const rem = document.getElementById('progress-remaining');
      if (marker) marker.style.left = `${percent}%`;
      if (complete) complete.style.width = `${percent}%`;
      if (pct) pct.textContent = `${percent}%`;
      if (rem) rem.textContent = `${mm}:${ss} remaining`;
    }

    // --- Skip to next task ---
    function skipToNextTask() {
      const { index } = getIntervalInfo();
      const dayKey = getTodayKey();
      const schedule = loadSchedule(dayKey);
      console.log(schedule);

      const currentTaskId = schedule[index] || null;
      // Find the first next scheduled task (no eligibility checks)
      let foundIndex = null;
      let foundTaskId = null;
      for (let i = index + 1; i < index + 1000; i++) {
        if (schedule[i]) { foundIndex = i; foundTaskId = schedule[i]; break; }
      }

      if (!foundTaskId) {
        // No next task; if current has a task, clear it (skip to free)
        if (currentTaskId) {
          delete schedule[index];
          saveSchedule(dayKey, schedule);
          renderOverview();
        }
        return;
      }

      // Move next task to now
      schedule[index] = foundTaskId;
      if (currentTaskId) {
        // Swap: move current task to where the next one came from
        schedule[foundIndex] = currentTaskId;
      } else {
        // Current was free; just pull forward
        delete schedule[foundIndex];
      }
      saveSchedule(dayKey, schedule);
      renderOverview();
    }

    function loadTagFilterSelection() {
      const raw = localStorage.getItem(TAG_FILTER_KEY);
      if (!raw) return [];
      try { const v = JSON.parse(raw); return Array.isArray(v) ? v : []; } catch { return []; }
    }
    function saveTagFilterSelection(selected) {
      localStorage.setItem(TAG_FILTER_KEY, JSON.stringify(selected || []));
    }

    function populateFilterOptions() {
      const group = document.getElementById('task-filter-group');
      if (!group) return;
      const tagsMap = loadTags();
      const tasks = loadTasks();
      const set = new Set(Object.keys(tagsMap));
      let hasUntagged = false;
      for (const t of tasks) {
        const tags = getTaskTags(t);
        if (tags.length === 0) hasUntagged = true;
        tags.forEach(tag => set.add(tag));
      }
      group.innerHTML = '';
      const selected = new Set(loadTagFilterSelection());
      const mk = (name, label) => {
        const id = 'tf_' + name.replace(/[^a-zA-Z0-9_-]/g, '_');
        const wrap = document.createElement('label');
        wrap.className = 'small';
        wrap.style.marginRight = '10px';
        const checkedAttr = selected.has(name) ? 'checked' : '';
        wrap.innerHTML = `<input type="checkbox" value="${name}" id="${id}" ${checkedAttr}> ${label}`;
        group.appendChild(wrap);
      };
      if (hasUntagged) mk('__UNTAGGED__', 'Untagged');
      Array.from(set).sort((a,b)=>a.localeCompare(b)).forEach(tag => mk(tag, tag));
      // Persist filter on change and re-render
      group.addEventListener('change', () => {
        const active = Array.from(group.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
        saveTagFilterSelection(active);
        renderTasksList();
      });
    }

    function renderTasksList() {
      const tasks = loadTasks();
      const tagsMap = loadTags();
      const root = document.getElementById('task-list');
      const group = document.getElementById('task-filter-group');
      const activeFilters = group ? Array.from(group.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value) : [];
      root.innerHTML = '';
      if (tasks.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'muted small';
        empty.textContent = 'No tasks yet';
        root.appendChild(empty);
        return;
      }
      for (const t of tasks) {
        // Filter check
        const tTags = getTaskTags(t);
        const matchesFilter = activeFilters.length === 0 || activeFilters.some(f => (f === '__UNTAGGED__' ? tTags.length === 0 : tTags.includes(f)));
        if (!matchesFilter) continue;
        const hasEnabledFlag = t.enabled !== false; // default enabled for legacy items
        const tagAllowed = isTaskAllowedByTags(t, tagsMap);
        const isEnabled = hasEnabledFlag && tagAllowed;
        // Build eligibility explanation for Next task
        const { index: currentIdx } = getIntervalInfo();
        const dayKey = getTodayKey();
        const schedule = loadSchedule(dayKey);
        let nextAt = null;
        for (const k of Object.keys(schedule)) {
          const ii = parseInt(k, 10);
          if (!Number.isNaN(ii) && ii >= currentIdx + 1 && schedule[k] === t.id) {
            if (nextAt === null || ii < nextAt) nextAt = ii;
          }
        }
        const disabledTags = tTags.length === 0
          ? ((tagsMap['Untagged'] && tagsMap['Untagged'].enabled === false) ? ['Untagged'] : [])
          : tTags.filter(tag => !isTagEnabled(tag, tagsMap));
        const reasons = [];
        if (!hasEnabledFlag) reasons.push('Task disabled');
        if (disabledTags.length > 0) reasons.push(`Tag(s) disabled: ${disabledTags.join(', ')}`);
        if (nextAt === null) reasons.push('Not scheduled in upcoming intervals today');
        const eligibilityNote = reasons.length === 0
          ? `<div class="small muted">Eligible for Next task; next at #${nextAt}</div>`
          : `<div class="small muted">Not eligible for Next task: ${reasons.join('; ')}</div>`;

        const row = document.createElement('div');
        row.className = 'interval';
        if (!isEnabled) row.classList.add('disabled');
        row.innerHTML = `
          <div>
            <div class="task">${t.title}</div>
            <div class="meta">${t.intervalsNeeded} interval(s) ${isEnabled ? '' : '<span class=\"pill\" style=\"margin-left:6px;\">Disabled</span>'}</div>
            <div class="tags">${(getTaskTags(t).length ? getTaskTags(t) : ['Untagged']).map(tag => `<span class=\"tag\">${tag}</span>`).join('')}</div>
            ${eligibilityNote}
          </div>
          <div class="menu-wrap">
            <button class="menu-trigger" aria-haspopup="true" aria-expanded="false" aria-label="Task actions">â‹¯</button>
            <div class="menu" role="menu">
              <button class="menu-item" data-action="move-up" data-id="${t.id}" role="menuitem">Move up</button>
              <button class="menu-item" data-action="move-down" data-id="${t.id}" role="menuitem">Move down</button>
              <button class="menu-item" data-action="toggle" data-id="${t.id}" role="menuitem">${isEnabled ? 'Disable' : 'Enable'}</button>
              <button class="menu-item" data-action="make-next" data-id="${t.id}" role="menuitem">Make next</button>
              <button class="menu-item danger" data-action="delete" data-id="${t.id}" role="menuitem">Delete</button>
            </div>
          </div>
        `;

        const trigger = row.querySelector('.menu-trigger');
        const menu = row.querySelector('.menu');
        trigger.addEventListener('click', (e) => {
          e.stopPropagation();
          // Close other open menus
          document.querySelectorAll('.menu.open').forEach(m => { if (m !== menu) m.classList.remove('open'); });
          document.querySelectorAll('.menu-trigger[aria-expanded="true"]').forEach(b => { if (b !== trigger) b.setAttribute('aria-expanded', 'false'); });
          const isOpen = menu.classList.toggle('open');
          trigger.setAttribute('aria-expanded', String(isOpen));
        });

        menu.addEventListener('click', (e) => { e.stopPropagation(); });

        const toggleBtn = row.querySelector('[data-action="toggle"]');
        toggleBtn.addEventListener('click', () => {
          const all = loadTasks();
          const idx = all.findIndex(x => x.id === t.id);
          if (idx !== -1) {
            const nextEnabled = !(all[idx].enabled !== false);
            all[idx].enabled = nextEnabled;
            saveTasks(all);
            // If disabling, remove from today's schedule
            if (!nextEnabled) {
              const dayKey = getTodayKey();
              const schedule = loadSchedule(dayKey);
              for (const k of Object.keys(schedule)) {
                if (schedule[k] === t.id) delete schedule[k];
              }
              saveSchedule(dayKey, schedule);
            }
            menu.classList.remove('open');
            trigger.setAttribute('aria-expanded', 'false');
            renderTasksList();
            renderOverview();
          }
        });

        const moveUpBtn = row.querySelector('[data-action="move-up"]');
        if (moveUpBtn) {
          moveUpBtn.addEventListener('click', () => {
            const all = loadTasks();
            const idx = all.findIndex(x => x.id === t.id);
            if (idx > 0) {
              const tmp = all[idx - 1];
              all[idx - 1] = all[idx];
              all[idx] = tmp;
              saveTasks(all);
            }
            menu.classList.remove('open');
            trigger.setAttribute('aria-expanded', 'false');
            renderTasksList();
          });
        }

        const moveDownBtn = row.querySelector('[data-action="move-down"]');
        if (moveDownBtn) {
          moveDownBtn.addEventListener('click', () => {
            const all = loadTasks();
            const idx = all.findIndex(x => x.id === t.id);
            if (idx !== -1 && idx < all.length - 1) {
              const tmp = all[idx + 1];
              all[idx + 1] = all[idx];
              all[idx] = tmp;
              saveTasks(all);
            }
            menu.classList.remove('open');
            trigger.setAttribute('aria-expanded', 'false');
            renderTasksList();
          });
        }

        const makeNextBtn = row.querySelector('[data-action="make-next"]');
        if (makeNextBtn) {
          makeNextBtn.addEventListener('click', () => {
            // Ensure the task is enabled
            const all = loadTasks();
            const tIdx = all.findIndex(x => x.id === t.id);
            if (tIdx !== -1) {
              all[tIdx].enabled = true;
              saveTasks(all);
            }
            // Assign to next interval
            const { index: currentIdx } = getIntervalInfo();
            const dayKey = getTodayKey();
            const schedule = loadSchedule(dayKey);
            schedule[currentIdx + 1] = t.id;
            saveSchedule(dayKey, schedule);
            menu.classList.remove('open');
            trigger.setAttribute('aria-expanded', 'false');
            renderTasksList();
            renderOverview();
          });
        }

        const deleteBtn = row.querySelector('[data-action="delete"]');
        deleteBtn.addEventListener('click', () => {
          const updated = tasks.filter(x => x.id !== t.id);
          saveTasks(updated);
          // Also remove from today's schedule
          const dayKey = getTodayKey();
          const schedule = loadSchedule(dayKey);
          for (const k of Object.keys(schedule)) {
            if (schedule[k] === t.id) delete schedule[k];
          }
          saveSchedule(dayKey, schedule);
          // Close the menu and refresh
          menu.classList.remove('open');
          trigger.setAttribute('aria-expanded', 'false');
          renderTasksList();
          renderOverview();
        });
        root.appendChild(row);
      }

      // Global outside-click to close menus
      if (!window.__tiMenuGlobalAttached) {
        window.__tiMenuGlobalAttached = true;
        document.addEventListener('click', () => {
          document.querySelectorAll('.menu.open').forEach(m => m.classList.remove('open'));
          document.querySelectorAll('.menu-trigger[aria-expanded="true"]').forEach(b => b.setAttribute('aria-expanded', 'false'));
        });
      }
      // nothing else; checkboxes are live-wired in populateFilterOptions
    }

    // --- Scheduling ---
    function assignTaskToNextIntervals(taskId, intervalsCount, startIndex) {
      const dayKey = getTodayKey();
      const schedule = loadSchedule(dayKey);
      let assigned = 0;
      let i = Math.max(0, startIndex);
      const hardCap = i + 500; // safety
      while (assigned < intervalsCount && i < hardCap) {
        if (!(i in schedule)) {
          schedule[i] = taskId;
          assigned += 1;
        }
        i += 1;
      }
      saveSchedule(dayKey, schedule);
      return assigned;
    }
    function renderTagSuggestions() {
      const list = document.getElementById('tag-suggestions');
      if (!list) return;
      const tagsMap = loadTags();
      list.innerHTML = '';
      Object.keys(tagsMap).sort().forEach(tag => {
        const opt = document.createElement('option');
        opt.value = tag;
        list.appendChild(opt);
      });
    }
    function renderTagsSettings() {
      const container = document.getElementById('tag-list');
      if (!container) return;
      container.innerHTML = '';
      const tagsMap = loadTags();
      const tasks = loadTasks();
      const set = new Set(Object.keys(tagsMap));
      let hasUntagged = false;
      for (const t of tasks) {
        const tags = getTaskTags(t);
        if (tags.length === 0) hasUntagged = true;
        tags.forEach(tag => set.add(tag));
      }
      if (hasUntagged) set.add('Untagged');
      if (set.size === 0) {
        const empty = document.createElement('div');
        empty.className = 'muted small';
        empty.textContent = 'No tags yet. Add tags when creating tasks.';
        container.appendChild(empty);
        return;
      }
      const sorted = Array.from(set).sort((a,b) => a.localeCompare(b));
      for (const name of sorted) {
        const enabled = name === 'Untagged' ? (tagsMap['Untagged'] ? tagsMap['Untagged'].enabled !== false : true) : isTagEnabled(name, tagsMap);
        const row = document.createElement('div');
        row.className = 'interval';
        row.innerHTML = `
          <div>
            <div class="task">${name}</div>
            <div class="meta">${enabled ? 'Enabled' : 'Disabled'}</div>
          </div>
          <label class="small"><input type="checkbox" ${enabled ? 'checked' : ''} data-tag-name="${name}"> Enable</label>
        `;
        const checkbox = row.querySelector('input[type="checkbox"]');
        checkbox.addEventListener('change', () => {
          const map = loadTags();
          const tagName = checkbox.getAttribute('data-tag-name');
          if (!map[tagName]) map[tagName] = { enabled: true };
          map[tagName].enabled = checkbox.checked;
          saveTags(map);
          // If disabling, remove from next intervals only
          if (!checkbox.checked) {
            const { index: currentIdx } = getIntervalInfo();
            const dayKey = getTodayKey();
            const schedule = loadSchedule(dayKey);
            const tasksAll = loadTasks();
            const ids = tasksAll.filter(t => {
              const tags = getTaskTags(t);
              if (tagName === 'Untagged') return tags.length === 0;
              return tags.includes(tagName);
            }).map(t => t.id);
            for (const k of Object.keys(schedule)) {
              const intervalIndex = parseInt(k, 10);
              if (!Number.isNaN(intervalIndex) && intervalIndex >= currentIdx + 1) {
                if (ids.includes(schedule[k])) delete schedule[k];
              }
            }
            saveSchedule(dayKey, schedule);
          }
          renderTagsSettings();
          renderTasksList();
          renderOverview();
        });
        container.appendChild(row);
      }
    }

    // --- Event wiring ---
    function hookTabs() {
      const buttons = Array.from(document.querySelectorAll('.tab-btn'));
      const screens = {
        overview: document.getElementById('screen-overview'),
        add: document.getElementById('screen-add'),
        settings: document.getElementById('screen-settings'),
      };
      function activate(tab) {
        buttons.forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
        Object.entries(screens).forEach(([key, el]) => {
          el.classList.toggle('active', key === tab);
        });
        if (tab === 'overview') renderOverview();
        if (tab === 'add') { populateFilterOptions(); renderTasksList(); renderTagSuggestions(); }
        if (tab === 'settings') {
          const s = loadSettings();
          document.getElementById('interval-mins').value = s.intervalMinutes;
          renderTagsSettings();
        }
      }
      buttons.forEach(b => b.addEventListener('click', () => activate(b.dataset.tab)));
    }

    function hookActions() {
      document.getElementById('add-btn').addEventListener('click', () => {
        const title = String(document.getElementById('task-title').value || '').trim();
        const tagsInputRaw = String(document.getElementById('task-tags')?.value || '');
        const tagCandidates = tagsInputRaw.split(',').map(s => normalizeTagName(s)).filter(Boolean);
        const intervalsNeeded = Math.max(1, parseInt(document.getElementById('task-intervals').value || '1', 10));
        const startNext = document.getElementById('start-next').checked;
        if (!title) {
          alert('Please enter a title');
          return;
        }
        const tasks = loadTasks();
        const tagsMap = loadTags();
        // Auto-create new tags typed by user
        for (const tName of tagCandidates) {
          if (!tagsMap[tName]) tagsMap[tName] = { enabled: true };
        }
        saveTags(tagsMap);
        const task = {
          id: 't_' + Date.now(),
          title,
          intervalsNeeded,
          enabled: true,
          tags: tagCandidates,
          createdAt: Date.now(),
        };
        tasks.push(task);
        saveTasks(tasks);

        const { index } = getIntervalInfo();
        const startIndex = startNext ? index + 1 : index;
        assignTaskToNextIntervals(task.id, intervalsNeeded, startIndex);

        // Clear form and refresh
        document.getElementById('task-title').value = '';
        if (document.getElementById('task-tags')) document.getElementById('task-tags').value = '';
        document.getElementById('task-intervals').value = '1';
        populateFilterOptions();
        renderTagSuggestions();
        renderTasksList();
        renderOverview();
      });

      document.getElementById('save-settings').addEventListener('click', () => {
        const mins = Math.max(1, parseInt(document.getElementById('interval-mins').value || '25', 10));
        saveSettings({ intervalMinutes: mins });
        // Reset today's schedule as cadence changed
        const dayKey = getTodayKey();
        localStorage.removeItem(SCHEDULE_PREFIX + dayKey);
        renderOverview();
        alert('Settings saved');
      });

      document.getElementById('reset-today').addEventListener('click', () => {
        const dayKey = getTodayKey();
        localStorage.removeItem(SCHEDULE_PREFIX + dayKey);
        renderOverview();
        alert("Today's schedule reset");
      });

      // Refresh overview every minute to update ranges and current index indicator
      setInterval(() => {
        if (document.getElementById('screen-overview').classList.contains('active')) {
          renderOverview();
        }
      }, 30 * 1000);

      // Progress bar tick
      setInterval(updateCurrentIntervalProgress, 1000);

      // Next task button removed per request
    }

    // --- Init ---
    (function init() {
      ensureScheduleConsistency();
      hookTabs();
      hookActions();
      // Build a full-day schedule from 12:00 AM by cycling through available tasks
      ensureCyclicScheduleForToday();
      renderOverview();
      populateFilterOptions();
      renderTagSuggestions();
      updateCurrentIntervalProgress();
    })();
  </script>
</body>
</html>


