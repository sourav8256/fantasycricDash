<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Task Planner</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #0078d4;
            --secondary-color: #106ebe;
            --text-color: #333;
            --bg-color: #f5f5f5;
            --card-bg: #fff;
            --border-color: #e0e0e0;
            --low-priority: #5db300;
            --medium-priority: #ffaa44;
            --high-priority: #d13438;
            --completed-color: #107c10;
        }

        body.dark-mode {
            --primary-color: #0078d4;
            --secondary-color: #106ebe;
            --text-color: #f5f5f5;
            --bg-color: #1e1e1e;
            --card-bg: #2d2d2d;
            --border-color: #444;
            --low-priority: #5db300;
            --medium-priority: #ffaa44;
            --high-priority: #d13438;
            --completed-color: #107c10;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom */
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 1.5rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        button {
            background-color: transparent;
            border: 1px solid white;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            touch-action: manipulation; /* Explicitly prevent double-tap zoom on interactive elements */
        }

        button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .search-box {
            position: relative;
        }

        .search-box input {
            padding: 0.5rem 1rem 0.5rem 2.5rem;
            border-radius: 4px;
            border: none;
        }

        .search-box i {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
        }

        .theme-switch {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: white;
        }

        main {
            padding: 1rem;
            overflow-x: auto;
        }

        .board {
            display: flex;
            gap: 1rem;
            min-height: calc(100vh - 120px);
        }

        .bucket {
            background-color: var(--card-bg);
            border-radius: 4px;
            min-width: 300px;
            max-width: 300px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .bucket-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            touch-action: manipulation; /* Explicitly prevent double-tap zoom on interactive elements */
        }

        .bucket-name {
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .bucket-name-edit {
            font-weight: 600;
            border: none;
            background: transparent;
            border-bottom: 1px solid var(--primary-color);
            font-size: inherit;
            padding: 0 0 2px 0;
            width: 80%;
            color: var(--text-color);
            outline: none;
        }

        .add-task {
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
        }

        .task-list {
            padding: 1rem;
            flex-grow: 1;
            min-height: 50px;
            overflow-y: auto;
        }
        
        .quick-add-task {
            display: flex;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .quick-add-task input {
            flex-grow: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--card-bg);
            color: var(--text-color);
        }
        
        .quick-add-task input::placeholder {
            color: #888;
            font-style: italic;
        }
        
        .quick-add-task input:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .completed-section {
            border-top: 1px dashed var(--border-color);
            margin-top: 1rem;
        }
        
        .completed-header {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            color: #666;
            display: flex;
            align-items: center;
            cursor: pointer;
            touch-action: manipulation; /* Explicitly prevent double-tap zoom on interactive elements */
        }
        
        .completed-header i {
            margin-right: 0.5rem;
        }
        
        .completed-tasks {
            padding: 0 1rem 1rem 1rem;
            overflow-y: auto;
        }
        
        .completed-tasks .task-card {
            opacity: 0.8;
        }
        
        .collapse-completed .completed-tasks {
            display: none;
        }

        .add-bucket {
            border: 2px dashed var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--primary-color);
            cursor: pointer;
            min-width: 300px;
            max-width: 300px;
            padding: 1rem;
            border-radius: 4px;
            background-color: var(--card-bg);
        }

        .add-bucket:hover {
            background-color: rgba(0, 120, 212, 0.05);
        }

        .task-card {
            background-color: var(--card-bg);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .task-card:hover {
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }
        
        .task-drag-handle {
            position: absolute;
            left: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            cursor: grab;
            color: #aaa;
            font-size: 0.8rem;
            padding: 0.25rem;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        
        .task-card:hover .task-drag-handle {
            opacity: 1;
        }
        
        .task-drag-handle:hover {
            color: var(--primary-color);
        }
        
        .drag-placeholder {
            border: 2px dashed var(--primary-color);
            background-color: rgba(0, 120, 212, 0.05);
            margin-bottom: 1rem;
            border-radius: 4px;
            height: 60px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        /* Add styling for the placeholder sequence number */
        .placeholder-sequence {
            position: absolute;
            top: 0.3rem;
            left: 0.3rem;
            font-size: 0.8rem;
            font-weight: bold;
            padding: 0.1rem 0.4rem;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
            color: #666;
        }
        
        .task-card.dragging {
            opacity: 0.5;
            transform: scale(0.98);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
        }
        
        .task-complete-checkbox {
            position: absolute;
            top: 0.7rem;
            right: 0.7rem;
            width: 18px;
            height: 18px;
            cursor: pointer;
            z-index: 5;
        }
        
        .completed-tasks .task-complete-checkbox {
            opacity: 1;
        }

        .task-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            padding-right: 25px;
        }

        .task-description {
            font-size: 0.9rem;
            color: #666;
        }

        .task-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: #666;
        }

        .priority {
            display: inline-block;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.75rem;
            color: white;
            font-weight: 600;
        }

        .priority.low {
            background-color: var(--low-priority);
        }

        .priority.medium {
            background-color: var(--medium-priority);
        }

        .priority.high {
            background-color: var(--high-priority);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .modal-content {
            background-color: var(--card-bg);
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-color);
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-color);
        }

        input, textarea, select {
            width: 100%;
            padding: 0.8rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--text-color);
        }

        .subtasks {
            margin-top: 1rem;
        }

        .subtask-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .subtask-checkbox {
            margin-right: 0.5rem;
            width: auto;
        }

        .add-subtask {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .subtask-actions {
            margin-left: auto;
            display: flex;
            gap: 0.5rem;
        }

        .delete-subtask, .edit-subtask {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 0.25rem;
        }

        .delete-subtask:hover, .edit-subtask:hover {
            color: var(--primary-color);
        }

        .task-description {
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            color: #555;
        }

        .action-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .save-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
        }

        .cancel-btn {
            background-color: transparent;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .task-details {
            margin-top: 1rem;
        }

        .subtask-list {
            list-style-type: none;
            margin-top: 0.5rem;
        }

        .drag-over {
            background-color: rgba(0, 120, 212, 0.1);
        }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #333;
            color: white;
            padding: 1rem;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
            z-index: 1001;
            transform: translateY(100px);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .undo-btn {
            background-color: white;
            color: #333;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .board {
                flex-wrap: wrap;
            }
            .bucket, .add-bucket {
                min-width: 100%;
                max-width: 100%;
            }

            /* Modify buttons to show only icons on mobile */
            .filter-btn span,
            #add-bucket-btn span,
            #export-btn span,
            #import-btn span {
                display: none;
            }

            /* Adjust button padding for icons only */
            .filter-btn,
            #add-bucket-btn,
            #export-btn,
            #import-btn {
                padding: 0.7rem;
                min-width: 44px;
                width: 44px; /* Fixed width for consistent sizing */
                justify-content: center;
            }

            /* Make icons slightly larger for better touch targets */
            .filter-btn i,
            #add-bucket-btn i,
            #export-btn i,
            #import-btn i {
                font-size: 1.2rem;
            }

            /* Ensure proper spacing between icon-only buttons */
            .controls {
                gap: 0.5rem;
            }
        }

        .filter-dropdown {
            position: relative;
            display: inline-block;
        }

        .filter-btn {
            background-color: transparent;
            border: 1px solid white;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
        }

        .filter-content {
            display: none;
            position: absolute;
            background-color: var(--card-bg);
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 4px;
            right: 0;
        }

        .filter-dropdown.active .filter-content {
            display: block;
        }

        .filter-option {
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            color: var(--text-color);
            cursor: pointer;
        }

        .filter-option:hover {
            background-color: rgba(0, 120, 212, 0.1);
        }

        /* Update the header styles for mobile */
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                padding: 0.5rem;
                gap: 0.5rem;
            }

            .controls {
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
                gap: 0.5rem;
            }

            .search-box {
                width: 100%;
                order: -1; /* Move search to top */
            }

            .search-box input {
                width: 100%;
            }

            /* Make buttons more touch-friendly */
            button {
                padding: 0.7rem 1rem;
                min-height: 44px; /* Minimum touch target size */
                min-width: 44px;
            }

            /* Adjust task cards for mobile */
            .task-card {
                padding: 1rem 0.5rem 1rem 2rem; /* More space for drag handle */
                touch-action: none; /* Better touch handling */
            }

            .task-drag-handle {
                left: 0.3rem;
                padding: 0.5rem;
                opacity: 1; /* Always visible on mobile */
            }

            /* Adjust bucket width for mobile */
            .bucket, .add-bucket {
                min-width: 100%;
                max-width: 100%;
                margin: 0 0 1rem 0;
            }

            /* Adjust modal for mobile */
            .modal-content {
                width: 95%;
                max-height: 85vh;
                margin: 1rem;
                padding: 1rem;
            }

            /* Make form inputs more touch-friendly */
            input, textarea, select {
                padding: 0.8rem;
                font-size: 16px; /* Prevent iOS zoom */
            }

            /* Adjust filter dropdown for mobile */
            .filter-content {
                position: fixed;
                left: 0;
                right: 0;
                top: auto;
                bottom: 0;
                width: 100%;
                max-height: 50vh;
                border-radius: 1rem 1rem 0 0;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                z-index: 1000;
            }

            .filter-option {
                padding: 1rem;
                border-bottom: 1px solid var(--border-color);
            }

            /* Adjust notification position for mobile */
            .notification {
                left: 1rem;
                right: 1rem;
                bottom: 1rem;
                width: auto;
            }

            /* Improve scrolling on mobile */
            .board {
                flex-direction: column;
                padding: 0.5rem;
                height: calc(100vh - 120px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Make completed section more touch-friendly */
            .completed-header {
                padding: 1rem;
                font-size: 1rem;
            }

            /* Adjust quick add task input for mobile */
            .quick-add-task input {
                padding: 0.8rem;
                font-size: 16px;
            }
        }

        /* Add support for landscape mode */
        @media (max-width: 768px) and (orientation: landscape) {
            .board {
                flex-direction: row;
                flex-wrap: nowrap;
                overflow-x: auto;
                height: calc(100vh - 140px);
            }

            .bucket, .add-bucket {
                min-width: 300px;
                max-width: 300px;
                margin: 0 0.5rem;
                height: 100%;
            }

            .task-list {
                max-height: calc(100vh - 250px);
            }
        }

        /* Update the bucket edit icon styles */
        .bucket-edit-icon {
            display: none; /* Hidden by default on desktop */
            color: white; /* Change from rgba(255, 255, 255, 0.7) to solid white */
            cursor: pointer;
            padding: 0.3rem;
            font-size: 1rem;
            margin-left: 0.5rem;
        }

        .bucket-edit-icon:hover {
            color: rgba(255, 255, 255, 0.8);
        }

        @media (max-width: 768px) {
            .bucket-name {
                font-size: 1rem;
                display: flex;
                align-items: center;
            }

            .bucket-edit-icon {
                display: inline-block; /* Show on mobile */
                color: var(--primary-color); /* Match the app's primary color */
            }

            /* Update bucket header for better visibility */
            .bucket-header {
                padding: 0.8rem;
                background-color: var(--card-bg);
                border-bottom: 2px solid var(--border-color);
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Task Planner</h1>
        <div class="controls">
            <div class="search-box">
                <i class="fas fa-search"></i>
                <input type="text" id="search-input" placeholder="Search tasks...">
            </div>
            <div class="filter-dropdown">
                <button class="filter-btn">
                    <i class="fas fa-filter"></i>
                    <span>Filter</span>
                </button>
                <div class="filter-content">
                    <div class="filter-option" data-filter="all">All Tasks</div>
                    <div class="filter-option" data-filter="low">Low Priority</div>
                    <div class="filter-option" data-filter="medium">Medium Priority</div>
                    <div class="filter-option" data-filter="high">High Priority</div>
                    <div class="filter-option" data-filter="overdue">Overdue</div>
                </div>
            </div>
            <button id="add-bucket-btn">
                <i class="fas fa-plus"></i>
                <span>Add Bucket</span>
            </button>
            <button id="export-btn">
                <i class="fas fa-download"></i>
                <span>Export</span>
            </button>
            <button id="import-btn">
                <i class="fas fa-upload"></i>
                <span>Import</span>
            </button>
            <input type="file" id="import-file" accept=".json" style="display: none;">
            <button class="theme-switch" id="theme-toggle"><i class="fas fa-moon"></i></button>
        </div>
    </header>

    <main>
        <div class="board" id="board">
            <!-- Buckets will be generated here -->
        </div>
    </main>

    <!-- Task Modal -->
    <div class="modal" id="task-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Add New Task</h3>
                <button class="close-modal">&times;</button>
            </div>
            <form id="task-form">
                <input type="hidden" id="task-id">
                <input type="hidden" id="bucket-id">
                <div class="form-group">
                    <label for="task-title">Title</label>
                    <input type="text" id="task-title" required>
                </div>
                <div class="form-group">
                    <label for="task-description">Description</label>
                    <textarea id="task-description" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label for="task-due-date">Due Date</label>
                    <input type="date" id="task-due-date">
                </div>
                <div class="form-group">
                    <label for="task-priority">Priority</label>
                    <select id="task-priority">
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high">High</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Subtasks</label>
                    <div id="subtasks-container" class="subtasks">
                        <!-- Subtasks will be added here -->
                    </div>
                    <div class="add-subtask">
                        <input type="text" id="new-subtask" placeholder="Add a subtask">
                        <button type="button" id="add-subtask-btn">Add</button>
                    </div>
                </div>
                <div class="action-buttons">
                    <button type="button" class="cancel-btn">Cancel</button>
                    <button type="submit" class="save-btn">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Bucket Modal -->
    <div class="modal" id="bucket-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Add New Bucket</h3>
                <button class="close-modal">&times;</button>
            </div>
            <form id="bucket-form">
                <input type="hidden" id="edit-bucket-id">
                <div class="form-group">
                    <label for="bucket-name">Bucket Name</label>
                    <input type="text" id="bucket-name" required>
                </div>
                <div class="action-buttons">
                    <button type="button" class="cancel-btn">Cancel</button>
                    <button type="submit" class="save-btn">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- View Task Modal -->
    <div class="modal" id="view-task-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="view-task-title">Task Title</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="task-details">
                <p id="view-task-description"></p>
                <div class="task-meta">
                    <div id="view-task-due-date"></div>
                    <div id="view-task-priority"></div>
                </div>
                <div class="subtasks">
                    <h4>Subtasks</h4>
                    <ul class="subtask-list" id="view-subtasks-list">
                        <!-- Subtasks will be added here -->
                    </ul>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="view-task-progress"></div>
                </div>
            </div>
            <div class="action-buttons">
                <button type="button" id="edit-task-btn" class="save-btn">Edit</button>
                <button type="button" id="delete-task-btn" class="cancel-btn">Delete</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification">
        <span id="notification-message">Task moved to Completed</span>
        <button class="undo-btn" id="undo-btn">Undo</button>
    </div>

    <script>
        // Data management
        let appData = {
            buckets: [],
            lastTaskId: 0,
            lastAction: null,
            lastFocusedBucketId: null // Track which bucket's input was last focused
        };

        // DOM Elements
        const board = document.getElementById('board');
        const taskModal = document.getElementById('task-modal');
        const bucketModal = document.getElementById('bucket-modal');
        const viewTaskModal = document.getElementById('view-task-modal');
        const taskForm = document.getElementById('task-form');
        const bucketForm = document.getElementById('bucket-form');
        const addBucketBtn = document.getElementById('add-bucket-btn');
        const themeToggle = document.getElementById('theme-toggle');
        const searchInput = document.getElementById('search-input');
        const notification = document.getElementById('notification');
        const notificationMessage = document.getElementById('notification-message');
        const undoBtn = document.getElementById('undo-btn');
        const filterDropdown = document.querySelector('.filter-dropdown');
        const filterBtn = document.querySelector('.filter-btn');
        const addSubtaskBtn = document.getElementById('add-subtask-btn');
        const newSubtaskInput = document.getElementById('new-subtask');

        // Load data from localStorage
        function loadData() {
            const savedData = localStorage.getItem('plannerAppData');
            if (savedData) {
                try {
                    appData = JSON.parse(savedData);
                    
                    // Ensure each bucket's tasks have proper sequence numbers
                    appData.buckets.forEach(bucket => {
                        // Process active and completed tasks separately
                        const activeTasks = bucket.tasks.filter(task => !task.completed);
                        const completedTasks = bucket.tasks.filter(task => task.completed);
                        
                        // Reset sequence numbers for active tasks
                        activeTasks.forEach((task, index) => {
                            if (task.completed === undefined) {
                                task.completed = false;
                            }
                            // Always assign a fresh sequence number
                            task.sequence = index + 1;
                        });
                        
                        // Reset sequence numbers for completed tasks
                        completedTasks.forEach((task, index) => {
                            if (task.completed === undefined) {
                                task.completed = true;
                            }
                            // Always assign a fresh sequence number
                            task.sequence = index + 1;
                        });
                    });
                    
                    // Initialize lastFocusedBucketId if it doesn't exist
                    if (!appData.lastFocusedBucketId && appData.buckets.length > 0) {
                        appData.lastFocusedBucketId = appData.buckets[0].id;
                    }
                    
                    // Save the updated data with fixed sequence numbers
                    saveData();
                } catch (e) {
                    console.error("Error loading data:", e);
                    // Initialize with default data if loading fails
                    resetToDefaultData();
                }
            } else {
                // Initialize with default buckets if no data exists
                resetToDefaultData();
            }
            renderBoard();
        }
        
        // Reset to default data
        function resetToDefaultData() {
            appData = {
                buckets: [
                    { id: 'todo', name: 'To Do', tasks: [] },
                    { id: 'inprogress', name: 'In Progress', tasks: [] }
                ],
                lastTaskId: 0,
                lastAction: null,
                lastFocusedBucketId: 'todo'
            };
            saveData();
        }

        // Save data to localStorage
        function saveData() {
            localStorage.setItem('plannerAppData', JSON.stringify(appData));
        }

        // Generate a unique ID for tasks
        function generateTaskId() {
            appData.lastTaskId++;
            saveData();
            return appData.lastTaskId;
        }

        // Render the entire board
        function renderBoard(skipFocus = false) {
            board.innerHTML = '';
            
            // Render each bucket
            appData.buckets.forEach(bucket => {
                const bucketElement = createBucketElement(bucket);
                board.appendChild(bucketElement);
            });
            
            // Add the "Add Bucket" button at the end
            const addBucketElement = document.createElement('div');
            addBucketElement.className = 'add-bucket';
            addBucketElement.innerHTML = '<i class="fas fa-plus"></i> Add Bucket';
            addBucketElement.addEventListener('click', () => openBucketModal());
            board.appendChild(addBucketElement);
            
            // Focus the appropriate quick add task input after rendering
            // But only if lastFocusedBucketId is set AND we're not skipping focus (for search)
            if (!skipFocus) {
                setTimeout(() => {
                    if (appData.lastFocusedBucketId) {
                        // Try to focus the last used bucket's input
                        const bucketInput = document.querySelector(`.quick-add-task input[data-bucket-id="${appData.lastFocusedBucketId}"]`);
                        if (bucketInput) {
                            bucketInput.focus();
                        } else {
                            // Fallback to first input if the bucket no longer exists
                            const firstQuickAddInput = document.querySelector('.quick-add-task input');
                            if (firstQuickAddInput) {
                                firstQuickAddInput.focus();
                                // Update the last focused bucket
                                if (firstQuickAddInput.dataset.bucketId) {
                                    appData.lastFocusedBucketId = firstQuickAddInput.dataset.bucketId;
                                    saveData();
                                }
                            }
                        }
                    }
                }, 100);
            }
        }

        // Create a bucket element
        function createBucketElement(bucket) {
            const bucketElement = document.createElement('div');
            bucketElement.className = 'bucket';
            bucketElement.dataset.id = bucket.id;
            
            const bucketHeader = document.createElement('div');
            bucketHeader.className = 'bucket-header';
            
            // Create bucket name element that can be edited on double click
            const bucketNameElement = document.createElement('div');
            bucketNameElement.className = 'bucket-name';
            bucketNameElement.innerHTML = `
                <span>${bucket.name}</span>
                <i class="fas fa-edit bucket-edit-icon"></i>
            `;
            
            // Add click handler for the edit icon
            const editIcon = bucketNameElement.querySelector('.bucket-edit-icon');
            editIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                // Create input element to edit the bucket name
                const inputElement = document.createElement('input');
                inputElement.type = 'text';
                inputElement.className = 'bucket-name-edit';
                inputElement.value = bucket.name;
                
                // Replace bucket name element with input
                bucketHeader.replaceChild(inputElement, bucketNameElement);
                
                // Focus the input
                inputElement.focus();
                
                // Select all text in the input
                inputElement.select();
                
                // Save on enter key
                inputElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveBucketName();
                    } else if (e.key === 'Escape') {
                        // Restore original name on escape
                        bucketHeader.replaceChild(bucketNameElement, inputElement);
                    }
                });
                
                // Save on blur (when focus is lost)
                inputElement.addEventListener('blur', saveBucketName);
                
                // Function to save the bucket name
                function saveBucketName() {
                    const newName = inputElement.value.trim();
                    if (newName && newName !== bucket.name) {
                        // Update bucket name in data
                        updateBucket(bucket.id, newName);
                    } else {
                        // If empty or unchanged, just restore the original element
                        bucketHeader.replaceChild(bucketNameElement, inputElement);
                    }
                }
            });
            
            // Keep the double-click handler for desktop
            bucketNameElement.addEventListener('dblclick', () => {
                editIcon.click(); // Reuse the edit icon click handler
            });
            
            const addTaskButton = document.createElement('button');
            addTaskButton.className = 'add-task';
            addTaskButton.innerHTML = '<i class="fas fa-plus"></i>';
            addTaskButton.dataset.bucket = bucket.id;
            
            bucketHeader.appendChild(bucketNameElement);
            bucketHeader.appendChild(addTaskButton);
            
            const taskList = document.createElement('div');
            taskList.className = 'task-list';
            taskList.dataset.bucketId = bucket.id;
            


            
            // Make the task list a drop target
            taskList.addEventListener('dragover', e => {
                e.preventDefault();
                taskList.classList.add('drag-over');
                
                const draggingElement = document.querySelector('.dragging');
                
                // Only handle reordering if we're dragging a task card
                if (draggingElement && draggingElement.classList.contains('task-card')) {
                    const targetBucketId = taskList.dataset.bucketId;
                    const taskId = draggingElement.dataset.id;
                    const taskResult = findTask(taskId);
                    
                    // Only proceed with reordering if we're in the same bucket
                    // and this is the active tasks list (not completed)
                    if (taskResult && taskResult.bucketId === targetBucketId && !taskResult.task.completed) {
                        // Get the tasks position from mouse position
                        const afterElement = getDragAfterElement(taskList, e.clientY);
                        
                        // Remove existing placeholder
                        const existingPlaceholder = taskList.querySelector('.drag-placeholder');
                        if (existingPlaceholder) {
                            existingPlaceholder.remove();
                        }
                        
                        // Create placeholder
                        const placeholder = document.createElement('div');
                        placeholder.className = 'drag-placeholder';
                        
                        // Calculate what the new sequence number would be
                        const bucket = appData.buckets.find(b => b.id === targetBucketId);
                        if (bucket) {
                            // Get all active tasks
                            const activeTasks = [...bucket.tasks.filter(t => !t.completed)];
                            
                            // Remove the dragged task temporarily
                            const draggedTaskIndex = activeTasks.findIndex(t => t.id == taskId);
                            if (draggedTaskIndex !== -1) {
                                activeTasks.splice(draggedTaskIndex, 1);
                            }
                            
                            // Sort tasks by sequence
                            activeTasks.sort((a, b) => a.sequence - b.sequence);
                            
                            // Determine placeholder position
                            let placeholderIndex = 0;
                            if (afterElement) {
                                const afterTaskId = afterElement.dataset.id;
                                const afterTaskIndex = activeTasks.findIndex(t => t.id == afterTaskId);
                                if (afterTaskIndex !== -1) {
                                    placeholderIndex = afterTaskIndex;
                                }
                            } else {
                                placeholderIndex = activeTasks.length;
                            }
                            
                            // Add sequence number indicator to placeholder
                            const sequenceIndicator = document.createElement('div');
                            sequenceIndicator.className = 'placeholder-sequence';
                            sequenceIndicator.textContent = `#${placeholderIndex + 1}`;
                            placeholder.appendChild(sequenceIndicator);
                            
                            // Update the visible sequence numbers on all task cards to show what they would be
                            // after the reordering
                            updateVisibleSequenceNumbers(targetBucketId, taskId, placeholderIndex);
                        }
                        
                        if (afterElement) {
                            taskList.insertBefore(placeholder, afterElement);
                        } else {
                            // Insert before the quick add task input
                            const quickAddTask = taskList.querySelector('.quick-add-task');
                            if (quickAddTask) {
                                taskList.insertBefore(placeholder, quickAddTask);
                            } else {
                                taskList.appendChild(placeholder);
                            }
                        }
                    }
                }
            });
            
            taskList.addEventListener('dragleave', () => {
                taskList.classList.remove('drag-over');
            });
            
            taskList.addEventListener('dragend', e => {
                // Reset all temporary sequence number displays
                resetVisibleSequenceNumbers();
            });
            
            taskList.addEventListener('drop', e => {
                e.preventDefault();
                taskList.classList.remove('drag-over');
                
                // Log drop coordinates and target information
                console.log("DROP EVENT DETAILS:");
                console.log(`- Mouse position: X: ${e.clientX}, Y: ${e.clientY}`);
                console.log(`- Drop target element:`, e.target);
                console.log(`- Current task list:`, taskList);
                
                const taskId = e.dataTransfer.getData('text/plain');
                let dragData = {};
                try {
                    const jsonData = e.dataTransfer.getData('application/json');
                    if (jsonData) {
                        dragData = JSON.parse(jsonData);
                        console.log(`- Drag data:`, dragData);
                    }
                } catch (err) {
                    console.error('Error parsing drag data:', err);
                }
                
                const taskResult = findTask(taskId);
                
                // Find the placeholder before removing it
                const placeholder = taskList.querySelector('.drag-placeholder');
                let placeholderIndex = -1;
                
                if (placeholder) {
                    // Log placeholder position details
                    const placeholderRect = placeholder.getBoundingClientRect();
                    console.log(`- Placeholder found:`, placeholder);
                    console.log(`- Placeholder position: top: ${placeholderRect.top}, bottom: ${placeholderRect.bottom}, height: ${placeholderRect.height}`);
                    
                    // Determine the placeholder's position among task cards
                    const taskCards = [...taskList.querySelectorAll('.task-card:not(.dragging):not(.completed-tasks .task-card)')];
                    const taskCardsWithPlaceholder = [...taskList.children].filter(el => 
                        el.classList.contains('task-card') || el.classList.contains('drag-placeholder'));
                    
                    console.log(`- Task cards:`, taskCards.map(card => card.dataset.id));
                    console.log(`- Task cards with placeholder:`, taskCardsWithPlaceholder.map(el => 
                        el.classList.contains('drag-placeholder') ? 'PLACEHOLDER' : el.dataset.id));
                    
                    // Find where the placeholder is in the list of elements
                    placeholderIndex = taskCardsWithPlaceholder.indexOf(placeholder);
                    console.log(`- Placeholder found at position: ${placeholderIndex}`);
                }
                
                // Clean up any placeholders
                document.querySelectorAll('.drag-placeholder').forEach(el => el.remove());
                
                if (!taskResult) {
                    console.error("Task not found:", taskId);
                    return;
                }
                
                const currentBucketId = taskList.dataset.bucketId;
                
                // Calculate drop position using getDragAfterElement
                const calculatedAfterElement = getDragAfterElement(taskList, e.clientY);
                console.log(`- Calculated after element:`, calculatedAfterElement ? calculatedAfterElement.dataset.id : 'null');
                
                if (taskResult.bucketId === currentBucketId && !taskResult.task.completed) {
                    // Reordering within the same bucket
                    console.log("-- Reordering within same bucket --");
                    
                    const bucket = appData.buckets.find(b => b.id === currentBucketId);
                    
                    if (!bucket) {
                        console.error("Bucket not found:", currentBucketId);
                        return;
                    }
                    
                    // Get non-completed tasks (active tasks)
                    const activeTasks = bucket.tasks.filter(t => !t.completed);
                    
                    // Force sequence numbers to be numeric
                    activeTasks.forEach(task => {
                        task.sequence = Number(task.sequence || 0);
                    });
                    
                    // Sort by sequence
                    activeTasks.sort((a, b) => a.sequence - b.sequence);
                    
                    console.log("Active tasks:", activeTasks.map(t => ({ id: t.id, title: t.title, seq: t.sequence })));
                    
                    // Current index in the full tasks array
                    const currentIndex = bucket.tasks.findIndex(t => t.id == taskId);
                    console.log(`Current index of task ${taskId} in bucket.tasks: ${currentIndex}`);
                    
                    // Current index in active tasks array (for sequence-based positioning)
                    const currentActiveIndex = activeTasks.findIndex(t => t.id == taskId);
                    console.log(`Current index of task ${taskId} in active tasks: ${currentActiveIndex}`);
                    
                    let newPosition = currentIndex; // Default to current position
                    let targetSequence = -1;
                    
                    // If we have a valid placeholder position, use it directly
                    if (placeholderIndex >= 0) {
                        console.log(`Using placeholder position: ${placeholderIndex}`);
                        
                        // Adjust for the task card that's being dragged since it's not in the DOM
                        // The new sequence should be the placeholder's position + 1
                        targetSequence = placeholderIndex + 1;
                        
                        // Now map this to an actual position in the task array
                        const activeTasksInBucket = [...bucket.tasks.filter(t => !t.completed)];
                        
                        // Remove the dragged task temporarily to find where it would go
                        const draggedTaskIndex = activeTasksInBucket.findIndex(t => t.id == taskId);
                        if (draggedTaskIndex !== -1) {
                            activeTasksInBucket.splice(draggedTaskIndex, 1);
                        }
                        
                        // Now sort by current sequence to simulate the DOM order
                        activeTasksInBucket.sort((a, b) => a.sequence - b.sequence);
                        
                        // If the placeholder is at the end
                        if (placeholderIndex >= activeTasksInBucket.length) {
                            // Position at the end of active tasks
                            newPosition = bucket.tasks.findIndex(t => !t.completed && 
                                activeTasksInBucket[activeTasksInBucket.length - 1].id == t.id) + 1;
                        } else {
                            // Position before the task at the placeholder position
                            const taskAtPlaceholder = activeTasksInBucket[placeholderIndex];
                            newPosition = bucket.tasks.findIndex(t => t.id == taskAtPlaceholder.id);
                        }
                        
                        console.log(`Target sequence: ${targetSequence}, new position: ${newPosition}`);
                    } else {
                        // Fallback to old method using afterElement if no placeholder found
                        const afterElement = getDragAfterElement(taskList, e.clientY);
                        
                        if (afterElement) {
                            // Get the task we're placing after
                            const afterTaskId = afterElement.dataset.id;
                            console.log(`Dropping after task ${afterTaskId}`);
                            
                            // Find where that task is in the full tasks array
                            const afterTaskIndex = bucket.tasks.findIndex(t => t.id == afterTaskId);
                            
                            if (afterTaskIndex !== -1) {
                                // If moving a task after itself, don't do anything
                                if (currentIndex === afterTaskIndex) {
                                    console.log("No change in position - same position");
                                    return;
                                }
                                
                                // If dropping after a task, we want to insert it right after
                                newPosition = afterTaskIndex;
                                
                                // If we're moving from before this position to after it,
                                // we need to adjust because the task will be removed first
                                if (currentIndex < afterTaskIndex) {
                                    newPosition--;
                                }
                                
                                console.log(`New position will be ${newPosition}`);
                            }
                        } else {
                            // If no afterElement, we're dropping at the end of active tasks
                            // Find the last active task
                            let lastActiveTaskIndex = -1;
                            for (let i = bucket.tasks.length - 1; i >= 0; i--) {
                                if (!bucket.tasks[i].completed && bucket.tasks[i].id != taskId) {
                                    lastActiveTaskIndex = i;
                                    break;
                                }
                            }
                            
                            if (lastActiveTaskIndex !== -1) {
                                newPosition = lastActiveTaskIndex + 1;
                                
                                // Adjust if the task being moved is before the insertion point
                                if (currentIndex < lastActiveTaskIndex) {
                                    newPosition--;
                                }
                                
                                console.log(`Dropping at end, new position: ${newPosition}`);
                            } else {
                                // If there are no other active tasks, position at beginning of active tasks
                                newPosition = 0;
                                console.log(`No other active tasks, positioning at beginning: ${newPosition}`);
                            }
                        }
                    }
                    
                    // Only reorder if the position is actually changing
                    if (newPosition !== currentIndex || targetSequence > 0) {
                        const currentSequence = taskResult.task.sequence || 0;
                        console.log(`Reordering from index ${currentIndex} to ${newPosition} (sequence: ${currentSequence} -> ${targetSequence > 0 ? targetSequence : '?'})`);
                        reorderTaskWithSequence(taskId, currentBucketId, newPosition, targetSequence);
                    } else {
                        console.log("No change in position - same index");
                    }
                } else {
                    // Moving between buckets
                    moveTask(taskId, currentBucketId, false);
                }
            });
            
            // Add active task cards to the list (non-completed tasks)
            const activeTasks = bucket.tasks.filter(task => !task.completed);
            
            // Force sequence numbers to be numeric for consistent sorting
            activeTasks.forEach(task => {
                if (task.sequence === undefined) {
                    task.sequence = 0;
                }
                // Ensure sequence is a number not a string
                task.sequence = Number(task.sequence);
            });
            
            // Sort tasks by sequence
            activeTasks.sort((a, b) => {
                return a.sequence - b.sequence;
            });
            
            console.log(`Bucket ${bucket.id} active tasks after sorting:`, 
                activeTasks.map(t => ({ id: t.id, title: t.title, seq: t.sequence })));
            
            activeTasks.forEach(task => {
                const taskCard = createTaskCard(task);
                taskList.appendChild(taskCard);
            });
            
            // Add quick task creation input
            const quickAddTask = document.createElement('div');
            quickAddTask.className = 'quick-add-task';
            
            const quickAddInput = document.createElement('input');
            quickAddInput.type = 'text';
            quickAddInput.placeholder = '+ Add a task...';
            quickAddInput.dataset.bucketId = bucket.id;
            
            quickAddInput.addEventListener('focus', () => {
                // Update the last focused bucket id when an input receives focus
                appData.lastFocusedBucketId = bucket.id;
                saveData();
            });
            
            quickAddInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    const taskTitle = e.target.value.trim();
                    if (taskTitle) {
                        // Create a new task with just the title
                        addTask(bucket.id, {
                            title: taskTitle,
                            description: '',
                            subtasks: [],
                            dueDate: '',
                            priority: 'medium'
                        });
                        
                        // Clear the input without triggering a blur
                        e.target.value = '';
                        
                        // Show notification
                        showNotification('Task added');
                        
                        // Make sure the current bucket is tracked as the last focused
                        appData.lastFocusedBucketId = bucket.id;
                        saveData();
                        
                        // Prevent the default enter behavior
                        e.preventDefault();
                        
                        // Render the board but skip the focus handling
                        renderBoard(true);
                        
                        // Force focus back to the input after a short delay
                        setTimeout(() => {
                            const input = document.querySelector(`.quick-add-task input[data-bucket-id="${bucket.id}"]`);
                            if (input) {
                                input.focus();
                            }
                        }, 10);
                    }
                }
            });
            
            quickAddTask.appendChild(quickAddInput);
            taskList.appendChild(quickAddTask);
            
            // Create completed section
            const completedSection = document.createElement('div');
            completedSection.className = 'completed-section collapse-completed';
            
            const completedHeader = document.createElement('div');
            completedHeader.className = 'completed-header';
            
            // Get count of completed tasks
            const completedTasks = bucket.tasks.filter(task => task.completed);
            const completedCount = completedTasks.length;
            
            completedHeader.innerHTML = `<i class="fas fa-chevron-right"></i> Completed (${completedCount})`;
            
            completedHeader.addEventListener('click', () => {
                completedSection.classList.toggle('collapse-completed');
                const icon = completedHeader.querySelector('i');
                if (completedSection.classList.contains('collapse-completed')) {
                    icon.className = 'fas fa-chevron-right';
                } else {
                    icon.className = 'fas fa-chevron-down';
                }
            });
            
            const completedTasksList = document.createElement('div');
            completedTasksList.className = 'completed-tasks';
            completedTasksList.dataset.bucketId = bucket.id;
            
            // Make the completed tasks list a drop target
            completedTasksList.addEventListener('dragover', e => {
                e.preventDefault();
                completedTasksList.classList.add('drag-over');
            });
            
            completedTasksList.addEventListener('dragleave', () => {
                completedTasksList.classList.remove('drag-over');
            });
            
            completedTasksList.addEventListener('drop', e => {
                e.preventDefault();
                completedTasksList.classList.remove('drag-over');
                
                const taskId = e.dataTransfer.getData('text/plain');
                moveTask(taskId, bucket.id, true);
            });
            
            // Add completed task cards
            completedTasks.forEach(task => {
                const taskCard = createTaskCard(task);
                completedTasksList.appendChild(taskCard);
            });
            
            completedSection.appendChild(completedHeader);
            completedSection.appendChild(completedTasksList);
            
            bucketElement.appendChild(bucketHeader);
            bucketElement.appendChild(taskList);
            bucketElement.appendChild(completedSection);
            
            return bucketElement;
        }

        // Create a task card
        function createTaskCard(task) {
            const taskCard = document.createElement('div');
            taskCard.className = 'task-card';
            taskCard.dataset.id = task.id;
            
            // Ensure every task has a sequence property
            if (task.sequence === undefined) {
                task.sequence = 0;
                console.warn(`Task ${task.id} had no sequence, assigned 0`);
            }
            
            // Convert sequence to number explicitly
            task.sequence = Number(task.sequence);
            
            taskCard.dataset.sequence = task.sequence; // Store sequence in data attribute
            taskCard.draggable = true;
            
            // Calculate progress percentage - still needed for other functionality
            let progress = 0;
            if (task.subtasks && task.subtasks.length > 0) {
                const completedSubtasks = task.subtasks.filter(subtask => subtask.completed).length;
                progress = Math.round((completedSubtasks / task.subtasks.length) * 100);
            }
            
            // Create completed checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'task-complete-checkbox';
            checkbox.checked = task.completed;
            checkbox.dataset.taskId = task.id;
            
            // Add drag handle
            const dragHandle = document.createElement('div');
            dragHandle.className = 'task-drag-handle';
            dragHandle.innerHTML = '<i class="fas fa-grip-lines"></i>';
            
            // Make the sequence display more noticeable
            const sequenceDisplay = document.createElement('div');
            sequenceDisplay.style.position = 'absolute';
            sequenceDisplay.style.top = '0.3rem';
            sequenceDisplay.style.left = '0.3rem';
            sequenceDisplay.style.fontSize = '0.8rem';
            sequenceDisplay.style.fontWeight = 'bold';
            sequenceDisplay.style.padding = '0.1rem 0.4rem';
            sequenceDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
            sequenceDisplay.style.borderRadius = '3px';
            sequenceDisplay.style.color = '#666';
            sequenceDisplay.textContent = `#${task.sequence}`;
            sequenceDisplay.dataset.originalSequence = `#${task.sequence}`;
            
            // Simplify the task card to just title and description
            taskCard.innerHTML = `
                <div class="task-title" style="margin-left: 15px;">${task.title}</div>
                <div class="task-description">${task.description.slice(0, 75)}${task.description.length > 75 ? '...' : ''}</div>
            `;
            
            // Append the checkbox, drag handle, and sequence display to the task card
            taskCard.appendChild(checkbox);
            taskCard.appendChild(dragHandle);
            taskCard.appendChild(sequenceDisplay);
            
            // Add checkbox event listener to toggle completion
            checkbox.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent opening task details when clicking checkbox
                
                const result = findTask(task.id);
                if (result) {
                    const isCompleted = e.target.checked;
                    result.task.completed = isCompleted;
                    
                    // Show notification
                    if (isCompleted) {
                        showNotification('Task marked as completed');
                    } else {
                        showNotification('Task marked as incomplete');
                    }
                    
                    saveData();
                    // Pass true to skip focus when rendering after completion
                    renderBoard(true);
                }
            });
            
            // Enhance drag event listeners for reordering
            taskCard.addEventListener('dragstart', e => {
                console.log(`Starting drag for task ${task.id} with sequence ${task.sequence}`);
                
                // Allow time for the ghost image to be created before adding the dragging class
                setTimeout(() => {
                    taskCard.classList.add('dragging');
                }, 0);
                
                // Store essential data for the drag operation
                e.dataTransfer.setData('text/plain', task.id);
                
                // Store additional data about the drag operation
                const result = findTask(task.id);
                const sourceBucketId = result ? result.bucketId : '';
                
                const dragInfo = {
                    id: task.id,
                    sequence: task.sequence,
                    sourceBucketId: sourceBucketId,
                    timestamp: Date.now() // Add timestamp to ensure unique operation
                };
                
                e.dataTransfer.setData('application/json', JSON.stringify(dragInfo));
                e.dataTransfer.effectAllowed = 'move';
            });
            
            taskCard.addEventListener('dragend', () => {
                console.log(`Ending drag for task ${task.id}`);
                taskCard.classList.remove('dragging');
                
                // Reset sequence displays to normal
                resetVisibleSequenceNumbers();
            });
            
            // Add click event to open task details (except when clicking drag handle)
            taskCard.addEventListener('click', (e) => {
                // Only open details if not clicking the checkbox or drag handle
                if (!e.target.classList.contains('task-complete-checkbox') && 
                    !e.target.closest('.task-drag-handle')) {
                    openViewTaskModal(task);
                }
            });
            
            // Prevent task card from opening when starting to drag
            dragHandle.addEventListener('mousedown', e => {
                e.stopPropagation();
            });
            
            return taskCard;
        }

        // Move a task between buckets
        function moveTask(taskId, targetBucketId, setCompleted = null) {
            // Find the task and source bucket
            let sourceTask = null;
            let sourceBucketId = null;
            let wasCompleted = false;
            let sourceTaskIndex = -1;
            
            for (const bucket of appData.buckets) {
                const taskIndex = bucket.tasks.findIndex(task => task.id == taskId);
                if (taskIndex !== -1) {
                    sourceTask = {...bucket.tasks[taskIndex]};
                    sourceTaskIndex = taskIndex;
                    wasCompleted = sourceTask.completed;
                    sourceBucketId = bucket.id;
                    bucket.tasks.splice(taskIndex, 1);
                    
                    // Update sequences for remaining tasks in source bucket
                    const remainingTasksInSection = bucket.tasks.filter(t => t.completed === wasCompleted);
                    remainingTasksInSection.forEach((t, index) => {
                        t.sequence = index + 1;
                    });
                    
                    break;
                }
            }
            
            if (sourceTask) {
                // Save the last action for potential undo
                appData.lastAction = {
                    type: 'move',
                    task: sourceTask,
                    sourceBucketId,
                    targetBucketId,
                    wasCompleted,
                    setCompleted,
                    originalIndex: sourceTaskIndex
                };
                
                // Set completed flag if specified
                if (setCompleted !== null) {
                    sourceTask.completed = setCompleted;
                }
                
                // Add to target bucket
                const targetBucket = appData.buckets.find(b => b.id === targetBucketId);
                if (targetBucket) {
                    // If moving to a different bucket or changing completion status,
                    // assign a new sequence at the end
                    if (targetBucketId !== sourceBucketId || wasCompleted !== sourceTask.completed) {
                        // Find the max sequence in the target section (active or completed)
                        const relevantTasks = targetBucket.tasks.filter(t => t.completed === sourceTask.completed);
                        let maxSequence = 0;
                        if (relevantTasks.length > 0) {
                            maxSequence = Math.max(...relevantTasks.map(t => t.sequence || 0));
                        }
                        sourceTask.sequence = maxSequence + 1;
                    }
                    
                    targetBucket.tasks.push(sourceTask);
                    
                    // Show notification when marking as completed
                    if (!wasCompleted && sourceTask.completed) {
                        showNotification('Task marked as completed');
                    } else if (targetBucketId !== sourceBucketId) {
                        showNotification(`Task moved to ${targetBucket.name}`);
                    }
                    
                    saveData();
                    renderBoard();
                }
            }
        }

        // Add a new task
        function addTask(bucketId, taskData) {
            const bucket = appData.buckets.find(b => b.id === bucketId);
            if (bucket) {
                // Find max sequence number in the bucket
                let maxSequence = 0;
                const activeTasks = bucket.tasks.filter(task => !task.completed);
                if (activeTasks.length > 0) {
                    maxSequence = Math.max(...activeTasks.map(task => task.sequence || 0));
                }
                
                const newTask = {
                    id: generateTaskId(),
                    title: taskData.title,
                    description: taskData.description || '',
                    subtasks: taskData.subtasks || [],
                    dueDate: taskData.dueDate || '',
                    priority: taskData.priority || 'medium',
                    completed: false,
                    sequence: maxSequence + 1 // Assign sequence number
                };
                
                bucket.tasks.push(newTask);
                saveData();
                renderBoard();
                return newTask;
            }
            return null;
        }

        // Update an existing task
        function updateTask(taskId, taskData) {
            for (const bucket of appData.buckets) {
                const taskIndex = bucket.tasks.findIndex(task => task.id == taskId);
                if (taskIndex !== -1) {
                    const wasCompleted = bucket.tasks[taskIndex].completed;
                    
                    // Update task properties
                    bucket.tasks[taskIndex] = {
                        ...bucket.tasks[taskIndex],
                        title: taskData.title,
                        description: taskData.description || '',
                        subtasks: taskData.subtasks || [],
                        dueDate: taskData.dueDate || '',
                        priority: taskData.priority || 'medium'
                    };
                    
                    // Check if all subtasks are completed
                    const allCompleted = bucket.tasks[taskIndex].subtasks.length > 0 && 
                        bucket.tasks[taskIndex].subtasks.every(subtask => subtask.completed);
                    
                    // Auto-mark as completed if all subtasks are done and not already completed
                    if (allCompleted && !bucket.tasks[taskIndex].completed) {
                        bucket.tasks[taskIndex].completed = true;
                        showNotification('Task automatically marked as completed');
                    }
                    
                    saveData();
                    renderBoard();
                    return true;
                }
            }
            return false;
        }

        // Delete a task
        function deleteTask(taskId) {
            for (const bucket of appData.buckets) {
                const taskIndex = bucket.tasks.findIndex(task => task.id == taskId);
                if (taskIndex !== -1) {
                    const deletedTask = bucket.tasks[taskIndex];
                    bucket.tasks.splice(taskIndex, 1);
                    
                    // Save for potential undo
                    appData.lastAction = {
                        type: 'delete',
                        task: deletedTask,
                        bucketId: bucket.id
                    };
                    
                    saveData();
                    renderBoard();
                    showNotification('Task deleted');
                    return true;
                }
            }
            return false;
        }

        // Add a new bucket
        function addBucket(name) {
            const id = 'bucket_' + Date.now();
            const newBucket = {
                id,
                name,
                tasks: []
            };
            
            appData.buckets.push(newBucket);
            saveData();
            renderBoard();
            return newBucket;
        }

        // Update bucket name
        function updateBucket(bucketId, name) {
            const bucket = appData.buckets.find(b => b.id === bucketId);
            if (bucket) {
                bucket.name = name;
                saveData();
                renderBoard();
                return true;
            }
            return false;
        }

        // Delete a bucket
        function deleteBucket(bucketId) {
            const bucketIndex = appData.buckets.findIndex(b => b.id === bucketId);
            if (bucketIndex !== -1) {
                appData.buckets.splice(bucketIndex, 1);
                saveData();
                renderBoard();
                return true;
            }
            return false;
        }

        // Find a task by ID
        function findTask(taskId) {
            for (const bucket of appData.buckets) {
                const task = bucket.tasks.find(t => t.id == taskId);
                if (task) {
                    return {
                        task,
                        bucketId: bucket.id
                    };
                }
            }
            return null;
        }

        // Show notification with undo option
        function showNotification(message) {
            notificationMessage.textContent = message;
            notification.classList.add('show');
            
            // Hide notification after 5 seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 5000);
        }

        // Undo last action
        function undoLastAction() {
            if (!appData.lastAction) return;
            
            const action = appData.lastAction;
            
            if (action.type === 'move') {
                // Undo task move
                for (const bucket of appData.buckets) {
                    const taskIndex = bucket.tasks.findIndex(task => task.id == action.task.id);
                    if (taskIndex !== -1) {
                        bucket.tasks.splice(taskIndex, 1);
                        break;
                    }
                }
                
                // Restore completion state
                if (action.wasCompleted !== undefined) {
                    action.task.completed = action.wasCompleted;
                }
                
                const sourceBucket = appData.buckets.find(b => b.id === action.sourceBucketId);
                if (sourceBucket) {
                    // Restore task at its original position
                    if (action.originalIndex >= 0 && action.originalIndex <= sourceBucket.tasks.length) {
                        sourceBucket.tasks.splice(action.originalIndex, 0, action.task);
                    } else {
                        sourceBucket.tasks.push(action.task);
                    }
                    
                    // Update sequences
                    const tasksInSection = sourceBucket.tasks.filter(t => t.completed === action.wasCompleted);
                    tasksInSection.forEach((t, index) => {
                        t.sequence = index + 1;
                    });
                }
            } else if (action.type === 'delete') {
                // Undo task delete
                const bucket = appData.buckets.find(b => b.id === action.bucketId);
                if (bucket) {
                    bucket.tasks.push(action.task);
                    
                    // Update sequences for tasks in the same section
                    const tasksInSection = bucket.tasks.filter(t => t.completed === action.task.completed);
                    tasksInSection.forEach((t, index) => {
                        t.sequence = index + 1;
                    });
                }
            } else if (action.type === 'reorder') {
                // Undo reordering by restoring the original array
                const bucket = appData.buckets.find(b => b.id === action.bucketId);
                if (bucket) {
                    bucket.tasks = action.originalTasks;
                }
            }
            
            // Clear last action
            appData.lastAction = null;
            saveData();
            renderBoard();
            notification.classList.remove('show');
        }

        // Search tasks
        function searchTasks(query) {
            // Store focus element for restoration after search
            const activeElement = document.activeElement;
            
            if (!query) {
                renderBoard();
                return;
            }
            
            query = query.toLowerCase();
            
            // Clone the buckets
            const filteredBuckets = appData.buckets.map(bucket => {
                return {
                    ...bucket,
                    tasks: bucket.tasks.filter(task => 
                        task.title.toLowerCase().includes(query) ||
                        task.description.toLowerCase().includes(query) ||
                        task.subtasks.some(subtask => subtask.text.toLowerCase().includes(query))
                    )
                };
            });
            
            // Replace the buckets temporarily for rendering
            const originalBuckets = appData.buckets;
            appData.buckets = filteredBuckets;
            
            // Pass true to renderBoard to skip auto-focusing inputs
            renderBoard(true);
            
            // Restore original data
            appData.buckets = originalBuckets;
            
            // Restore focus to search input
            if (activeElement) {
                setTimeout(() => {
                    activeElement.focus();
                }, 10);
            }
        }

        // Filter tasks
        function filterTasks(filterType) {
            // Store focus element for restoration
            const activeElement = document.activeElement;
            
            if (filterType === 'all') {
                renderBoard();
                return;
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Clone the buckets
            const filteredBuckets = appData.buckets.map(bucket => {
                return {
                    ...bucket,
                    tasks: bucket.tasks.filter(task => {
                        if (filterType === 'overdue') {
                            if (!task.dueDate) return false;
                            const dueDate = new Date(task.dueDate);
                            return dueDate < today;
                        } else {
                            return task.priority === filterType;
                        }
                    })
                };
            });
            
            // Replace the buckets temporarily for rendering
            const originalBuckets = appData.buckets;
            appData.buckets = filteredBuckets;
            
            // Pass true to renderBoard to skip auto-focusing inputs
            renderBoard(true);
            
            // Restore original data
            appData.buckets = originalBuckets;
            
            // Restore previous focus if needed
            if (activeElement && activeElement !== document.body) {
                setTimeout(() => {
                    activeElement.focus();
                }, 10);
            }
        }

        // Toggle dark mode
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            
            // Update the toggle button icon
            if (document.body.classList.contains('dark-mode')) {
                themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
                localStorage.setItem('darkMode', 'enabled');
            } else {
                themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
                localStorage.setItem('darkMode', 'disabled');
            }
        }

        // Check for saved dark mode preference
        function checkDarkModePreference() {
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
                themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
            }
        }

        // Open the task modal for adding/editing
        function openTaskModal(bucketId, taskId = null) {
            const modalTitle = document.querySelector('#task-modal .modal-title');
            const taskIdInput = document.getElementById('task-id');
            const bucketIdInput = document.getElementById('bucket-id');
            const taskTitleInput = document.getElementById('task-title');
            const taskDescriptionInput = document.getElementById('task-description');
            const taskDueDateInput = document.getElementById('task-due-date');
            const taskPriorityInput = document.getElementById('task-priority');
            const subtasksContainer = document.getElementById('subtasks-container');
            
            // Clear previous data
            taskForm.reset();
            subtasksContainer.innerHTML = '';
            
            if (taskId) {
                // Edit existing task
                const result = findTask(taskId);
                if (result) {
                    const { task } = result;
                    
                    modalTitle.textContent = 'Edit Task';
                    taskIdInput.value = task.id;
                    bucketIdInput.value = bucketId;
                    taskTitleInput.value = task.title;
                    taskDescriptionInput.value = task.description;
                    taskDueDateInput.value = task.dueDate;
                    taskPriorityInput.value = task.priority;
                    
                    // Add subtasks
                    task.subtasks.forEach((subtask, index) => {
                        addSubtaskToForm(subtask.text, subtask.completed, index);
                    });
                }
            } else {
                // Add new task
                modalTitle.textContent = 'Add New Task';
                taskIdInput.value = '';
                bucketIdInput.value = bucketId;
                
                // Set default date to tomorrow
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                taskDueDateInput.value = tomorrow.toISOString().split('T')[0];
            }
            
            taskModal.style.display = 'flex';
        }

        // Open the bucket modal for adding/editing
        function openBucketModal(bucketId = null) {
            const modalTitle = document.querySelector('#bucket-modal .modal-title');
            const bucketNameInput = document.getElementById('bucket-name');
            const editBucketIdInput = document.getElementById('edit-bucket-id');
            
            // Clear previous data
            bucketForm.reset();
            
            if (bucketId) {
                // Edit existing bucket
                const bucket = appData.buckets.find(b => b.id === bucketId);
                if (bucket) {
                    modalTitle.textContent = 'Edit Bucket';
                    bucketNameInput.value = bucket.name;
                    editBucketIdInput.value = bucketId;
                }
            } else {
                // Add new bucket
                modalTitle.textContent = 'Add New Bucket';
                editBucketIdInput.value = '';
            }
            
            bucketModal.style.display = 'flex';
        }

        // Open task view modal
        function openViewTaskModal(task) {
            const titleElement = document.getElementById('view-task-title');
            const descriptionElement = document.getElementById('view-task-description');
            const dueDateElement = document.getElementById('view-task-due-date');
            const priorityElement = document.getElementById('view-task-priority');
            const subtasksList = document.getElementById('view-subtasks-list');
            const progressBar = document.getElementById('view-task-progress');
            const editBtn = document.getElementById('edit-task-btn');
            const deleteBtn = document.getElementById('delete-task-btn');
            
            // Set task details
            titleElement.textContent = task.title;
            descriptionElement.textContent = task.description || 'No description provided';
            
            // Format due date
            if (task.dueDate) {
                const dueDate = new Date(task.dueDate);
                const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                dueDateElement.textContent = `Due: ${dueDate.toLocaleDateString('en-US', options)}`;
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                if (dueDate < today) {
                    dueDateElement.style.color = 'var(--high-priority)';
                    dueDateElement.textContent += ' (Overdue)';
                } else {
                    dueDateElement.style.color = '';
                }
            } else {
                dueDateElement.textContent = 'No due date';
                dueDateElement.style.color = '';
            }
            
            // Set priority
            priorityElement.textContent = `Priority: ${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}`;
            priorityElement.className = task.priority;
            
            // Add subtasks
            subtasksList.innerHTML = '';
            if (task.subtasks && task.subtasks.length > 0) {
                task.subtasks.forEach(subtask => {
                    const li = document.createElement('li');
                    li.className = 'subtask-item';
                    li.innerHTML = `
                        <input type="checkbox" class="subtask-checkbox" data-task-id="${task.id}" 
                               data-subtask-index="${task.subtasks.indexOf(subtask)}" 
                               ${subtask.completed ? 'checked' : ''}>
                        <span style="${subtask.completed ? 'text-decoration: line-through' : ''}">${subtask.text}</span>
                    `;
                    subtasksList.appendChild(li);
                });
                
                // We'll keep the progress calculation for subtasks in the detail view
                if (progressBar) {
                    const completedSubtasks = task.subtasks.filter(subtask => subtask.completed).length;
                    const progress = Math.round((completedSubtasks / task.subtasks.length) * 100);
                    progressBar.style.width = `${progress}%`;
                }
            } else {
                subtasksList.innerHTML = '<li>No subtasks</li>';
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
            }
            
            // Add completed toggle button
            const actionButtons = document.querySelector('#view-task-modal .action-buttons');
            let toggleBtn = document.getElementById('toggle-complete-btn');
            
            if (!toggleBtn) {
                toggleBtn = document.createElement('button');
                toggleBtn.type = 'button';
                toggleBtn.id = 'toggle-complete-btn';
                toggleBtn.className = task.completed ? 'cancel-btn' : 'save-btn';
                actionButtons.insertBefore(toggleBtn, editBtn);
            } else {
                toggleBtn.className = task.completed ? 'cancel-btn' : 'save-btn';
            }
            
            toggleBtn.textContent = task.completed ? 'Mark Incomplete' : 'Mark Complete';
            toggleBtn.dataset.taskId = task.id;
            toggleBtn.dataset.completed = task.completed;
            
            // Set up edit and delete buttons
            editBtn.dataset.taskId = task.id;
            deleteBtn.dataset.taskId = task.id;
            
            viewTaskModal.style.display = 'flex';
        }

        // Add a subtask to the form
        function addSubtaskToForm(text = '', completed = false, index = null) {
            const subtasksContainer = document.getElementById('subtasks-container');
            const subtaskItem = document.createElement('div');
            subtaskItem.className = 'subtask-item';
            
            const id = index !== null ? index : subtasksContainer.children.length;
            
            subtaskItem.innerHTML = `
                <input type="checkbox" class="subtask-checkbox" id="subtask-${id}" 
                       name="subtask-${id}-completed" ${completed ? 'checked' : ''}>
                <input type="text" name="subtask-${id}-text" value="${text}" placeholder="Subtask">
                <div class="subtask-actions">
                    <button type="button" class="delete-subtask"><i class="fas fa-trash"></i></button>
                </div>
            `;
            
            // Add delete event listener
            subtaskItem.querySelector('.delete-subtask').addEventListener('click', function() {
                subtaskItem.remove();
            });
            
            subtasksContainer.appendChild(subtaskItem);
        }

        // Close all modals
        function closeModals() {
            taskModal.style.display = 'none';
            bucketModal.style.display = 'none';
            viewTaskModal.style.display = 'none';
        }

        // Get data from task form
        function getTaskFormData() {
            const taskId = document.getElementById('task-id').value;
            const bucketId = document.getElementById('bucket-id').value;
            const title = document.getElementById('task-title').value;
            const description = document.getElementById('task-description').value;
            const dueDate = document.getElementById('task-due-date').value;
            const priority = document.getElementById('task-priority').value;
            
            // Collect subtasks
            const subtasks = [];
            const subtaskItems = document.querySelectorAll('.subtask-item');
            
            subtaskItems.forEach(item => {
                const textInput = item.querySelector('input[type="text"]');
                const checkbox = item.querySelector('input[type="checkbox"]');
                
                if (textInput && textInput.value.trim()) {
                    subtasks.push({
                        text: textInput.value.trim(),
                        completed: checkbox ? checkbox.checked : false
                    });
                }
            });
            
            return {
                taskId,
                bucketId,
                taskData: {
                    title,
                    description,
                    dueDate,
                    priority,
                    subtasks
                }
            };
        }

        // Event listeners
        function setupEventListeners() {
            // Add task buttons
            document.addEventListener('click', e => {
                if (e.target.closest('.add-task')) {
                    const bucketId = e.target.closest('.add-task').dataset.bucket;
                    openTaskModal(bucketId);
                }
            });
            
            // Toggle task completion button
            document.addEventListener('click', e => {
                if (e.target.id === 'toggle-complete-btn') {
                    const taskId = e.target.dataset.taskId;
                    const currentlyCompleted = e.target.dataset.completed === 'true';
                    
                    // Find the task and its bucket
                    const result = findTask(taskId);
                    if (result) {
                        result.task.completed = !currentlyCompleted;
                        
                        // Show notification
                        if (result.task.completed) {
                            showNotification('Task marked as completed');
                        } else {
                            showNotification('Task marked as incomplete');
                        }
                        
                        saveData();
                        // Pass true to skip focus when rendering after completion
                        renderBoard(true);
                        closeModals();
                    }
                }
            });
            
            // Close modal buttons
            document.querySelectorAll('.close-modal, .cancel-btn').forEach(button => {
                button.addEventListener('click', closeModals);
            });
            
            // Add bucket button
            addBucketBtn.addEventListener('click', () => openBucketModal());
            
            // Theme toggle
            themeToggle.addEventListener('click', toggleDarkMode);
            
            // Search input
            searchInput.addEventListener('input', e => {
                searchTasks(e.target.value.trim());
            });
            
            // Undo button
            undoBtn.addEventListener('click', undoLastAction);
            
            // Filter dropdown
            filterBtn.addEventListener('click', () => {
                filterDropdown.classList.toggle('active');
            });
            
            // Filter options
            document.querySelectorAll('.filter-option').forEach(option => {
                option.addEventListener('click', () => {
                    filterTasks(option.dataset.filter);
                    filterDropdown.classList.remove('active');
                });
            });
            
            // Close filter dropdown when clicking outside
            document.addEventListener('click', e => {
                if (!e.target.closest('.filter-dropdown')) {
                    filterDropdown.classList.remove('active');
                }
            });
            
            // Add subtask button
            addSubtaskBtn.addEventListener('click', () => {
                const newSubtaskText = newSubtaskInput.value.trim();
                if (newSubtaskText) {
                    addSubtaskToForm(newSubtaskText);
                    newSubtaskInput.value = '';
                }
            });
            
            // Enter key for adding subtasks
            newSubtaskInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addSubtaskBtn.click();
                }
            });
            
            // Subtask checkbox in view modal
            document.addEventListener('change', e => {
                if (e.target.classList.contains('subtask-checkbox') && e.target.dataset.taskId) {
                    const taskId = e.target.dataset.taskId;
                    const subtaskIndex = e.target.dataset.subtaskIndex;
                    
                    // Update the task
                    const result = findTask(taskId);
                    if (result) {
                        const { task } = result;
                        task.subtasks[subtaskIndex].completed = e.target.checked;
                        
                        // Update the UI
                        const span = e.target.nextElementSibling;
                        if (e.target.checked) {
                            span.style.textDecoration = 'line-through';
                        } else {
                            span.style.textDecoration = 'none';
                        }
                        
                        // Update progress bar
                        const completedSubtasks = task.subtasks.filter(subtask => subtask.completed).length;
                        const progress = Math.round((completedSubtasks / task.subtasks.length) * 100);
                        document.getElementById('view-task-progress').style.width = `${progress}%`;
                        
                        updateTask(taskId, task);
                    }
                }
            });
            
            // Edit task button
            document.getElementById('edit-task-btn').addEventListener('click', () => {
                const taskId = document.getElementById('edit-task-btn').dataset.taskId;
                const result = findTask(taskId);
                if (result) {
                    closeModals();
                    openTaskModal(result.bucketId, taskId);
                }
            });
            
            // Delete task button
            document.getElementById('delete-task-btn').addEventListener('click', () => {
                const taskId = document.getElementById('delete-task-btn').dataset.taskId;
                if (confirm('Are you sure you want to delete this task?')) {
                    deleteTask(taskId);
                    closeModals();
                }
            });
            
            // Task form submit
            taskForm.addEventListener('submit', e => {
                e.preventDefault();
                
                const { taskId, bucketId, taskData } = getTaskFormData();
                
                if (taskId) {
                    // Update existing task
                    updateTask(taskId, taskData);
                } else {
                    // Add new task
                    addTask(bucketId, taskData);
                }
                
                closeModals();
            });
            
            // Bucket form submit
            bucketForm.addEventListener('submit', e => {
                e.preventDefault();
                
                const bucketName = document.getElementById('bucket-name').value;
                const bucketId = document.getElementById('edit-bucket-id').value;
                
                if (bucketId) {
                    // Update existing bucket
                    updateBucket(bucketId, bucketName);
                } else {
                    // Add new bucket
                    addBucket(bucketName);
                }
                
                closeModals();
            });
            
            // Export button
            document.getElementById('export-btn').addEventListener('click', exportData);
            
            // Import button and file input
            document.getElementById('import-btn').addEventListener('click', () => {
                document.getElementById('import-file').click();
            });
            
            document.getElementById('import-file').addEventListener('change', importData);
        }

        // Initialize app
        function init() {
            const savedData = localStorage.getItem('plannerAppData');
            if (savedData) {
                // Initialize missing sequence numbers for legacy data
                const data = JSON.parse(savedData);
                let updated = false;
                
                data.buckets.forEach(bucket => {
                    // Separate active and completed tasks
                    const activeTasks = bucket.tasks.filter(task => !task.completed);
                    const completedTasks = bucket.tasks.filter(task => task.completed);
                    
                    // Check if any task is missing sequence number
                    const needsSequence = bucket.tasks.some(task => task.sequence === undefined);
                    
                    if (needsSequence) {
                        // Assign sequence numbers to active tasks
                        activeTasks.forEach((task, index) => {
                            if (task.sequence === undefined) {
                                task.sequence = index + 1;
                                updated = true;
                            }
                        });
                        
                        // Assign sequence numbers to completed tasks
                        completedTasks.forEach((task, index) => {
                            if (task.sequence === undefined) {
                                task.sequence = index + 1;
                                updated = true;
                            }
                        });
                    }
                });
                
                // Save the updated data if needed
                if (updated) {
                    localStorage.setItem('plannerAppData', JSON.stringify(data));
                }
            }
            
            loadData();
            setupEventListeners();
            checkDarkModePreference();
            
            // Focus on the appropriate quick add task input when the page loads
            setTimeout(() => {
                if (appData.lastFocusedBucketId) {
                    const bucketInput = document.querySelector(`.quick-add-task input[data-bucket-id="${appData.lastFocusedBucketId}"]`);
                    if (bucketInput) {
                        bucketInput.focus();
                    } else {
                        // Fallback to first input
                        const firstQuickAddInput = document.querySelector('.quick-add-task input');
                        if (firstQuickAddInput) {
                            firstQuickAddInput.focus();
                            // Update the last focused bucket
                            if (firstQuickAddInput.dataset.bucketId) {
                                appData.lastFocusedBucketId = firstQuickAddInput.dataset.bucketId;
                                saveData();
                            }
                        }
                    }
                }
            }, 500);
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', init);

        // Add this function to determine where to place the dragged element
        function getDragAfterElement(container, y) {
            
            // Get all task cards that are not being dragged
            const taskElements = [...container.querySelectorAll('.task-card:not(.dragging):not(.completed-tasks .task-card)')];
            
            if (taskElements.length === 0) {
                return null; // No other tasks to compare against
            }
            
            // Replace reduce with a simpler approach that won't generate logs
            let closestElement = null;
            let closestOffset = Number.NEGATIVE_INFINITY;
            
            // Loop through each element to find the closest
            for (const child of taskElements) {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                // We want to find the element where the mouse is closest to being above it
                // (i.e., the element with the smallest negative offset)
                if (offset < 0 && offset > closestOffset) {
                    closestOffset = offset;
                    closestElement = child;
                }
            }

            console.log(`-------------- GETTING DRAG AFTER ELEMENT --------------`);
            console.log(`Container:`, container);
            console.log(`Y:`, y);
            console.log(`Closest element:`, closestElement);
            return closestElement;
        }
        
        // Enhanced reordering function that uses sequence numbers directly
        function reorderTaskWithSequence(taskId, bucketId, newPosition, targetSequence) {
            console.log(`-------------- REORDERING TASK --------------`);
            console.log(`Task ID: ${taskId}, Target position: ${newPosition}, Target sequence: ${targetSequence}`);
            
            const bucket = appData.buckets.find(b => b.id === bucketId);
            if (!bucket) {
                console.error("Bucket not found!");
                return;
            }
            
            // Log the state of all tasks in the bucket before reordering
            console.log("BEFORE REORDERING - All tasks in bucket:");
            bucket.tasks.forEach(t => {
                console.log(`Task ID: ${t.id}, Title: "${t.title}", Sequence: ${t.sequence}, Completed: ${t.completed}`);
            });
            
            // Find the task to reorder by ID
            const taskToMove = bucket.tasks.find(task => task.id == taskId);
            if (!taskToMove) {
                console.error("Task not found in bucket!");
                return;
            }
            
            // Store original completion state
            const wasCompleted = taskToMove.completed;
            
            // Store original sequence
            const originalSequence = taskToMove.sequence;
            
            // Store original tasks for undo
            const originalTasks = JSON.parse(JSON.stringify(bucket.tasks));
            
            // Extract active tasks (or completed tasks depending on task's completion status)
            const tasksInSameSection = bucket.tasks.filter(t => t.completed === wasCompleted);
            
            console.log(`Working with ${wasCompleted ? 'completed' : 'active'} tasks. Found ${tasksInSameSection.length} tasks in this section.`);
            
            // Sort tasks by sequence to ensure proper order
            tasksInSameSection.sort((a, b) => Number(a.sequence) - Number(b.sequence));
            
            console.log("Tasks in same section sorted by sequence before changes:", 
                tasksInSameSection.map(t => ({ id: t.id, title: t.title, seq: t.sequence })));
            
            // If we have a specific target sequence provided, use it
            if (typeof targetSequence === 'number' && targetSequence > 0) {
                console.log(`Using provided target sequence: ${targetSequence}`);
                
                // Set the task's new sequence
                taskToMove.sequence = targetSequence;
                
                // Update all sequences to be consecutive
                // First, get all tasks in the section except the one we moved
                const otherTasks = tasksInSameSection.filter(t => t.id != taskId);
                
                // Insert our moved task at the right position based on its new sequence
                let inserted = false;
                let tempSequencedTasks = [];
                
                for (let i = 0; i < otherTasks.length; i++) {
                    if (!inserted && targetSequence <= i + 1) {
                        tempSequencedTasks.push(taskToMove);
                        inserted = true;
                    }
                    tempSequencedTasks.push(otherTasks[i]);
                }
                
                // If not inserted yet, add at the end
                if (!inserted) {
                    tempSequencedTasks.push(taskToMove);
                }
                
                // Now reassign sequences to be consecutive
                tempSequencedTasks.forEach((task, idx) => {
                    task.sequence = idx + 1;
                    console.log(`Set ${wasCompleted ? 'completed' : 'active'} task ${task.id} (${task.title}) sequence to ${task.sequence}`);
                });
            } else {
                console.log("No target sequence provided. Calculating based on position.");
                
                // Find the task's current position in the sorted array
                const currentIndex = tasksInSameSection.findIndex(t => t.id == taskId);
                
                // Remove the task from its current position
                if (currentIndex !== -1) {
                    tasksInSameSection.splice(currentIndex, 1);
                }
                
                // Determine the effective insertion position (based on the sorting by sequence, not DOM order)
                let insertPosition = Math.min(newPosition, tasksInSameSection.length);
                console.log(`Inserting at position ${insertPosition} in the sorted sequence array`);
                
                // Insert at the new position
                tasksInSameSection.splice(insertPosition, 0, taskToMove);
                
                // Reassign all sequence numbers to be consecutive
                tasksInSameSection.forEach((task, idx) => {
                    task.sequence = idx + 1;
                    console.log(`Updated task ${task.id} (${task.title}): new sequence = ${task.sequence}`);
                });
            }
            
            // Log the final sequence order
            console.log("AFTER REORDERING - Sequence order:");
            bucket.tasks.filter(t => t.completed === wasCompleted)
                .sort((a, b) => a.sequence - b.sequence)
                .forEach(t => {
                    console.log(`Task ID: ${t.id}, Title: "${t.title}", Sequence: ${t.sequence}`);
                });
            
            // Save the last action for potential undo
            appData.lastAction = {
                type: 'reorder',
                taskId: taskId,
                bucketId: bucketId,
                originalSequence: originalSequence,
                newSequence: taskToMove.sequence,
                originalTasks: originalTasks
            };
            
            // Force save ALL data to localStorage
            saveData();
            
            // Show notification
            showNotification('Task reordered');
            
            // Render the board with the new order
            renderBoard();
        }

        // Add this function to update sequence numbers visually during drag
        function updateVisibleSequenceNumbers(bucketId, excludedTaskId, newPosition) {
            const bucket = appData.buckets.find(b => b.id === bucketId);
            if (!bucket) return;
            
            // Get active tasks
            const activeTasks = bucket.tasks.filter(t => !t.completed);
            
            // Create a copy of tasks without the dragged one
            const remainingTasks = activeTasks.filter(t => t.id != excludedTaskId);
            
            // Sort by current sequence
            remainingTasks.sort((a, b) => a.sequence - b.sequence);
            
            // This is what the sequence numbers would be
            const taskElements = document.querySelectorAll(`.bucket[data-id="${bucketId}"] .task-list .task-card:not(.dragging):not(.completed-tasks .task-card)`);
            
            // Update each visible task card's sequence display
            taskElements.forEach(taskEl => {
                const taskId = taskEl.dataset.id;
                if (taskId != excludedTaskId) {
                    const taskIndex = remainingTasks.findIndex(t => t.id == taskId);
                    
                    // Determine what the new sequence would be
                    let newSequence = taskIndex + 1;
                    
                    // If this task would be after the insert position, increment its sequence
                    if (taskIndex >= newPosition) {
                        newSequence++;
                    }
                    
                    // Update the sequence display
                    const sequenceDisplay = taskEl.querySelector('[style*="position: absolute"][style*="top: 0.3rem"][style*="left: 0.3rem"]');
                    if (sequenceDisplay) {
                        // Add a class to indicate this is a temporary display
                        sequenceDisplay.classList.add('temp-sequence');
                        
                        // Remember original sequence
                        if (!sequenceDisplay.dataset.originalSequence) {
                            sequenceDisplay.dataset.originalSequence = sequenceDisplay.textContent;
                        }
                        
                        // Apply a visual style to indicate this is a preview
                        sequenceDisplay.style.backgroundColor = 'rgba(0, 120, 212, 0.2)';
                        
                        // Update text
                        sequenceDisplay.textContent = `#${newSequence}`;
                    }
                }
            });
        }
        
        // Reset sequence displays to their original values
        function resetVisibleSequenceNumbers() {
            const tempSequences = document.querySelectorAll('.temp-sequence');
            tempSequences.forEach(element => {
                if (element.dataset.originalSequence) {
                    element.textContent = element.dataset.originalSequence;
                    element.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                }
                element.classList.remove('temp-sequence');
                delete element.dataset.originalSequence;
            });
            
            // Remove any placeholder elements
            document.querySelectorAll('.drag-placeholder').forEach(el => el.remove());
        }
        
        // Export app data to JSON file
        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileName = `task-planner-backup-${new Date().toISOString().slice(0, 10)}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileName);
            linkElement.style.display = 'none';
            
            document.body.appendChild(linkElement);
            linkElement.click();
            document.body.removeChild(linkElement);
            
            showNotification('Data exported successfully');
        }
        
        // Import app data from JSON file
        function importData(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(event) {
                try {
                    const importedData = JSON.parse(event.target.result);
                    
                    // Validate that the imported data has the required structure
                    if (!importedData || !Array.isArray(importedData.buckets)) {
                        throw new Error('Invalid data format');
                    }
                    
                    // Create a backup of the current data
                    const currentData = JSON.stringify(appData);
                    localStorage.setItem('plannerAppDataBackup', currentData);
                    
                    // Import the new data
                    appData = importedData;
                    
                    // Ensure sequence numbers are valid
                    appData.buckets.forEach(bucket => {
                        // Process active and completed tasks separately
                        const activeTasks = bucket.tasks.filter(task => !task.completed);
                        const completedTasks = bucket.tasks.filter(task => task.completed);
                        
                        // Reset sequence numbers for active tasks
                        activeTasks.forEach((task, index) => {
                            if (task.completed === undefined) {
                                task.completed = false;
                            }
                            // Ensure sequence is a number
                            task.sequence = Number(task.sequence || (index + 1));
                        });
                        
                        // Reset sequence numbers for completed tasks
                        completedTasks.forEach((task, index) => {
                            if (task.completed === undefined) {
                                task.completed = true;
                            }
                            // Ensure sequence is a number
                            task.sequence = Number(task.sequence || (index + 1));
                        });
                    });
                    
                    // Initialize lastFocusedBucketId if needed
                    if (!appData.lastFocusedBucketId && appData.buckets.length > 0) {
                        appData.lastFocusedBucketId = appData.buckets[0].id;
                    }
                    
                    // Save and render the imported data
                    saveData();
                    renderBoard();
                    
                    showNotification('Data imported successfully');
                } catch (error) {
                    console.error('Import error:', error);
                    showNotification('Error importing data: ' + error.message);
                    
                    // Restore from backup if there was an error
                    const backup = localStorage.getItem('plannerAppDataBackup');
                    if (backup) {
                        try {
                            appData = JSON.parse(backup);
                            saveData();
                            renderBoard();
                        } catch (e) {
                            console.error('Error restoring backup:', e);
                        }
                    }
                }
                
                // Reset the file input
                e.target.value = '';
            };
            
            reader.onerror = function() {
                showNotification('Error reading file');
                // Reset the file input
                e.target.value = '';
            };
            
            reader.readAsText(file);
        }
    </script>
</body>
</html>
